#+TITLE: Emacs Configuration
#+LANGUAGE:  en
#+AUTHOR: Ryan Yanson
#+OPTIONS:   H:3 num:t   toc:3 \n:nil @:t ::t |:t ^:nil -:t f:t *:t <:nil
#+OPTIONS:   TeX:t LaTeX:nil skip:nil d:nil todo:t pri:nil tags:not-in-toc
#+OPTIONS:   author:t creator:t timestamp:t
#+DESCRIPTION: My custom emacs configuration
#+KEYWORDS:  My custom emacs configuration
#+EXPORT_SELECT_TAGS: export
#+EXPORT_EXCLUDE_TAGS: 
------
* Introduction
* Usage

This file can be used to load emacs provided use-package is available prior.  If use package is not available the sample init in the next section can be used to bootstrap use-package so that loading will work.  As long as use-package is in place all package downloads will happen automatically.

* Init.el
  
My init.el file contains the lines below.  It is just enough to bootstrap use-package and then load this document.

#+BEGIN_SRC emacs-lisp :tangle no
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;  Bootstrap use-package.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(require 'package)
(setq package-enable-at-startup nil)

(setq package-archives '(("org" . "http://orgmode.org/elpa/") 
                         ("gnu" . "http://elpa.gnu.org/packages/")
                         ("melpa" . "http://melpa.org/packages/")))

(package-initialize)

;;  Load use-package and s early as they are needed in the main config.
(unless (and (package-installed-p 'use-package)
             (package-installed-p 's))
  (package-refresh-contents)
  (package-install 'use-package)
  (package-install 's))

(eval-when-compile
  (require 'use-package))

(require 'diminish)
(require 'bind-key)
(require 's)

(setq use-package-verbose t)   

(add-hook 'after-init-hook (lambda () (org-babel-load-file "~/.emacs.d/emacs-config.org")))
#+END_SRC

* Startup

Start debugging so that if this file has errors I know about it.

#+BEGIN_SRC emacs-lisp :tangle yes :exports code
(setq debug-on-error t
      debug-on-quit t)
#+END_SRC

Start the server so that when editing I can connect and work quicker.

#+BEGIN_SRC emacs-lisp :tangle yes :exports code
(require 'server nil t)
(use-package server
  :if window-system
  :init
  (when (not (server-running-p))
    (server-start)))
#+END_SRC

* UTF-8

Prefer UTF-8 as the coding system.

#+BEGIN_SRC emacs-lisp :tangle yes :exports code
(prefer-coding-system 'utf-8)
(set-default-coding-systems 'utf-8)
(set-terminal-coding-system 'utf-8)
(set-keyboard-coding-system 'utf-8)
(setq default-buffer-file-coding-system 'utf-8)
#+END_SRC

* GUI

I found this on [[http://doc.rix.si/org/fsem.html][Hardcore Freestyle Emacs]].  They are defined early so they can be used in this section.

#+BEGIN_SRC emacs-lisp :tangle yes :exports code
(defun windows-p ()
  "Returns t if the system is a native Emacs for Windows, otherwise nil"
  (string-equal system-type "windows-nt"))
#+END_SRC

Used to determine if Emacs is being launched at work or not.

#+BEGIN_SRC emacs-lisp :tangle yes :exports code
(defun at-work-p ()
  "Return t if the system name contains \"RAD\"."
  (s-contains? "RAD" (system-name)))
#+END_SRC

Remove visual clutter and gain a little more room on the screen.
  
#+BEGIN_SRC emacs-lisp :tangle yes :exports code
(if (fboundp 'scroll-bar-mode) (scroll-bar-mode -1))
(if (fboundp 'tool-bar-mode) (tool-bar-mode -1))
(if (fboundp 'menu-bar-mode) (menu-bar-mode -1))
#+END_SRC

Remove the splash screen.  

#+BEGIN_SRC emacs-lisp :tangle yes :exports code
(setq inhibit-splash-screen t)
#+END_SRC

Make the cursor a bar instead of a box.

#+BEGIN_SRC emacs-lisp :tangle yes :exports code
(setq cursor-type 'bar)
#+END_SRC

The mode-line is configured using the code below.  I like to have a simplified mode-line so many of the usual things have been removed.

#+BEGIN_SRC emacs-lisp :tangle yes :exports code
(defface ry/current-task-face
  '((t (:foreground "gold")))
  "Face for current task in mode-line."
  :group 'faces)

(defface ry/current-time-face
  '((t (:foreground "gold")))
  "Face for current task time in mode-line."
  :group 'faces)

(defun ry/current-task-time ()
  "Concat the current clocking item and the time spent into a
propertized string.  If no item is being clocked return a no
clocking string"
  (cond (org-clock-current-task
         (concat 
          (propertize org-clock-current-task 'face 'ry/current-task-face)
          " : "
          (propertize (org-minutes-to-clocksum-string (org-clock-get-clocked-time)) 'face 'ry/current-time-face)))
        ((get-buffer "CAPTURE-refile.org")
         (propertize "Capturing" 'face 'ry/current-time-face))
        (t
         (propertize "Not clocking" 'face 'ry/current-time-face))))

(setq-default mode-line-format
              '("%e"
                mode-line-front-space
                "%b"
                "  "
                mode-line-position
                (vc-mode vc-mode)
                "  "
                mode-line-modes              
                "  "
                "Current task: "
                (:eval (ry/current-task-time))
                mode-line-end-spaces))
#+END_SRC

This is the Solarized color theme that is common to VIM.  I change the mode-line to have a different color and also change a couple faces for code block in org-mode so that they stand out more.

#+BEGIN_SRC emacs-lisp :tangle yes :exports code
(use-package solarized-theme
  :ensure t
  :config
  (progn
    (load-theme 'solarized-dark t)
    (set-face-attribute 'mode-line nil
                        :inverse-video t
                        :weight 'bold
                        :overline nil
                        :underline nil
                        :box nil
                        :foreground "#93a1a1"
                        :background "#073642")
    (set-face-attribute 'mode-line-inactive nil
                        :inverse-video t
                        :weight 'bold
                        :overline nil
                        :underline nil
                        :box nil
                        :foreground "#657b83"                        
                        :background "#073642")

    ;;  Remove the lines between buffers.
    (set-face-attribute 'vertical-border nil :foreground (face-attribute 'fringe :background))

    (with-eval-after-load 'org
      (set-face-attribute 'org-block-begin-line nil
                          :underline t
                          :background "#073642")
      (set-face-attribute 'org-block-end-line nil
                          :overline t
                          :background "#073642"))))
      ;; Removed from org-mode.  I hope they add it back.
      ;;(set-face-attribute 'org-block-background nil
        ;;                  :background "#073642"))))
#+END_SRC

Set the default font.  I flip-flop between Consolas and Inconsolata.  Both are nice fonts.

#+BEGIN_SRC emacs-lisp :tangle yes :exports code 
(when (display-graphic-p)
    (cond ((x-list-fonts "Inconsolata")
           (add-to-list 'default-frame-alist '(font . "Inconsolata-11"))
           (set-face-attribute 'default t :font "Inconsolata-11"))
          ((x-list-fonts "Consolas")
           (add-to-list 'default-frame-alist '(font . "Consolas-11"))
           (set-face-attribute 'default t :font "Consolas-11"))))
#+END_SRC

Disable the file dialog.

#+BEGIN_SRC emacs-lisp :tangle yes :exports code 
(setq use-file-dialog nil)
#+END_SRC

Use 'Y' and 'N' instead of yes and no for prompts.

#+BEGIN_SRC emacs-lisp :tangle yes :exports code 
(fset 'yes-or-no-p 'y-or-n-p)
#+END_SRC

Stripe dired buffers and org-mode tables for easier reading.

#+BEGIN_SRC emacs-lisp :tangle yes :exports code
(use-package stripe-buffer
  :ensure t
  :defer t
  :config
  (progn
    (add-hook 'dired-mode-hook 'stripe-listify-buffer)
    (add-hook 'org-mode-hook 'turn-on-stripe-table-mode)
    (setq stripe-hl-line "#073642")
    (set-face-attribute stripe-highlight-face nil :background "#073642")))
#+END_SRC

Indicate in the left fringe where the end of a buffer is.

#+BEGIN_SRC emacs-lisp :tangle yes :exports code
(set-default 'indicate-empty-lines t)
#+END_SRC

* Load work config

Load environment variables that are particular to my work machine.

#+BEGIN_SRC emacs-lisp :tangle yes :exports code
(if (at-work-p)
    (load "~/emacs/Config/its-config.el" t))
#+END_SRC

* Environment

Setup PATH and some other environment stuff.

#+BEGIN_SRC emacs-lisp :tangle yes :exports code 
(when (windows-p)
  (setq exec-path
        (append exec-path
                '("~/emacs/Graphviz/bin"
                  "~/emacs/Hunspell/bin/"
                  "~/emacs/Gnutls/bin"
                  "~/emacs/Leiningen"
                  "~/Git/bin"))))
#+END_SRC

Set the path to the trustfiles used by GnuTLS after the gnutls module is loaded.  Setting it prior to load does not work properly.  Also setting this path does not work unless the full path is provided.

#+BEGIN_SRC emacs-lisp :tangle yes :exports code 
(when (windows-p)
  (eval-after-load "gnutls" 
    '(progn 
       (setq gnutls-trustfiles '("h:/emacs/cacert.pem")
             gnutls-log-level 1))))
#+END_SRC

Set values so that backup files are not littering my directories.  The BACKUP folder will be ignored by git.  Backup files regardless of if they are in versio control or not.

#+BEGIN_SRC emacs-lisp :tangle yes :exports code 
(setq backup-directory-alist `((".*" . "~/.emacs.d/BACKUP"))
      auto-save-file-name-transforms `((".*" , "~/.emacs.d/BACKUP" t))
      version-control t
      delete-old-versions t
      vc-make-backup-files t)
#+END_SRC

Change garbage collection to only happen every 20 MB.  Originally found on https://github.com/CQQL/dotfiles/blob/master/src/.emacs.d/lisp/globals.el

#+BEGIN_SRC emacs-lisp :tangle yes :exports code 
(setq gc-cons-threshold 100000000
      jit-lock-stealth-time 1
      ;; jit-lock-stealth-load 200
      jit-lock-chunk-size 1000
      jit-lock-defer-time 0.05)
#+END_SRC

Save the history of the mini buffer.

#+BEGIN_SRC emacs-lisp :tangle yes :exports code
(setq savehist-file "~/.emacs.d/savehist"
      history-length t
      history-delete-duplicates t
      savehist-save-minibuffer-history 1
      savehist-additional-variables '(kill-ring
                                      search-ring
                                      regexp-search-ring))
(savehist-mode 1)
#+END_SRC

Another garbage collection related snippet that I found on: http://bling.github.io/blog/2016/01/18/why-are-you-changing-gc-cons-threshold/.  This will alter the threshold that is set in the snippt above so it needs to be tested and then altered if needed.

#+BEGIN_SRC emacs-lisp :tangle yes :exports code
(defun my-minibuffer-setup-hook ()
  (setq gc-cons-threshold most-positive-fixnum))

(defun my-minibuffer-exit-hook ()
  (setq gc-cons-threshold 800000))

(add-hook 'minibuffer-setup-hook #'my-minibuffer-setup-hook)
(add-hook 'minibuffer-exit-hook #'my-minibuffer-exit-hook)
#+END_SRC

* Navigation
** Avy Jump

Avy jump looks like it could be helpful.  The configuration needs to be updated to include keybindings.  I originaly also had key chord mixed in here but decided that it was not going to get any use.

#+BEGIN_SRC emacs-lisp :tangle yes :exports code
(use-package avy
  :ensure t
  :bind (("C-z" . avy-goto-char-timer)))
#+END_SRC

* Searching

Anzu is a visual regular expression/replace package.  It includes some nice highlighting ability while doing replaces or searches.

#+BEGIN_SRC emacs-lisp :tangle yes :exports code
(use-package anzu
  :ensure t
  :diminish anzu-mode
  :bind (("C-M-s" . anzu-query-replace)
         ("C-M-%" . anzu-query-replace-regexp)))
#+END_SRC

Change the behavior of i-search.

http://endlessparentheses.com/leave-the-cursor-at-start-of-match-after-isearch.html?source=rss

#+BEGIN_SRC emacs-lisp :tangle yes :exports code
(add-hook 'isearch-mode-end-hook
          #'endless/goto-match-beginning)
(defun endless/goto-match-beginning ()
  "Go to the start of current isearch match.
Use in `isearch-mode-end-hook'."
  (when (and isearch-forward
             (number-or-marker-p isearch-other-end)
             (not mark-active)
             (not isearch-mode-end-hook-quit))
    (goto-char isearch-other-end)))
#+END_SRC

* Misc. settings

Not sure if this is a good thing or a bad thing but I got tired of having to see the messages from the advise system telling me that a couple definitions got changed.

#+BEGIN_SRC emacs-lisp :tangle yes :exports code
(setq ad-redefinition-action 'accept)
#+END_SRC

Make apropos a little more helpful.

#+BEGIN_SRC emacs-lisp :tangle yes :exports code 
(setq apropos-do-all t)
#+END_SRC

Show the current function name in the status line.

#+BEGIN_SRC emacs-lisp :tangle yes :exports code 
(which-function-mode 1)
#+END_SRC

This removes the message that is displayed when killing a buffer in server mode.

#+BEGIN_SRC emacs-lisp :tangle yes :exports code 
(remove-hook 'kill-buffer-query-functions 'server-kill-buffer-query-function)
#+END_SRC

The following disables the warning message that appears when a huge change is made to a buffer.  When working with SQL results sometimes the buffer gets large and I remove a large portion of the buffer contents.  Normally a warning message would show but I don't want it to.

#+BEGIN_SRC emacs-lisp :tangle yes :exports code
;(add-to-list 'warning-suppress-types '(undo discard-info)) 
#+END_SRC

I work with log files quite often and sometimes they are very large.  The setting below will allow files to be opened without warnings until they are over 100MB in size.

#+BEGIN_SRC emacs-lisp :tangle yes :exports code 
(set-default 'large-file-warning-threshold 1000000000)
#+END_SRC

Automatically revert the buffer to the contents of the file on the disk if it has changed.

#+BEGIN_SRC emacs-lisp :tangle yes :exports code 
(global-auto-revert-mode t)
#+END_SRC

This will quit all processes without prompting me to do so when closing Emacs.

#+BEGIN_SRC emacs-lisp :tangle yes :exports code
(require 'cl)
(defadvice save-buffers-kill-emacs (around no-query-kill-emacs activate)
           (cl-flet ((process-list ())) ad-do-it))
#+END_SRC

Change the map of other window to something a little easier to hit.

#+BEGIN_SRC emacs-lisp :tangle yes :exports code
(global-set-key (kbd "M-o") #'other-window)
#+END_SRC

* Editing

Enable editing functions that are disabled by default.

#+BEGIN_SRC emacs-lisp :tangle yes :exports code
(put 'upcase-region 'disabled nil)
(put 'downcase-region 'disabled nil)

(put 'narrow-to-region 'disabled nil) 
(put 'narrow-to-page 'disabled nil) 
(put 'narrow-to-defun 'disabled nil) 

(put 'erase-buffer 'disabled nil)
#+END_SRC

I dislike the way that Emacs scrolls by default.  I also do not feel like brining in an extra package for scrolling so this is a compromise.

#+BEGIN_SRC emacs-lisp :tangle yes :exports code 
(setq scroll-margin 5
      scroll-preserve-screen-position 1)
#+END_SRC

Like scrolling the default recenter command has a strange order that recenters happen.  This was a very nice pickup from Abo Abo.

#+BEGIN_SRC emacs-lisp :tangle yes :exports code 
(setq recenter-positions '(top middle bottom))
#+END_SRC

With this option enabled a highlighted region will be overwritten if one is active and I start typing.  This makes Emacs behave like other editors.

#+BEGIN_SRC emacs-lisp :tangle yes :exports code 
(delete-selection-mode t) 
#+END_SRC

Enable transient mark mode so that highlighting regions activates special behaviors.

#+BEGIN_SRC emacs-lisp :tangle yes :exports code 
(setq transient-mark-mode t)
#+END_SRC

Disable the annoying blinking cursor.

#+BEGIN_SRC emacs-lisp :tangle yes :exports code 
(blink-cursor-mode 0) 
#+END_SRC

This setting is used to truncate lines instead of wrapping them.  I like the idea of visual-line-mode but never got used to it.

#+BEGIN_SRC emacs-lisp :tangle yes :exports code 
;;(set-default 'truncate-lines t)
(global-visual-line-mode)
(setq line-move-visual t
      visual-line-fringe-indicators '(left-curly-arrow right-curly-arrow))
#+END_SRC

Use four spaces in place of tab characters.  Things get weird when programs don't treat tabs the same.

#+BEGIN_SRC emacs-lisp :tangle yes :exports code 
(setq-default indent-tabs-mode nil
              tab-width 4)
#+END_SRC

The following is an alternative to the typical M-SPC key binding that does different things based on how many times you use it.

#+BEGIN_SRC emacs-lisp :tangle yes :exports code
(bind-key "M-SPC" 'cycle-spacing)
#+END_SRC

I am starting to get used to idea of setting mark and moving back and forth.  This key binding was taken from Sacha Chua.  

#+BEGIN_SRC emacs-lisp :tangle yes :exports code 
(bind-key "C-x p" 'pop-to-mark-command)
(setq set-mark-command-repeat-pop t)
#+END_SRC

Commands for dealing with rectangular regions.  Found on the emacs wiki.

#+BEGIN_SRC emacs-lisp :tangle yes :exports code
(global-set-key (kbd "C-x r M-w") 'my-copy-rectangle)
(global-set-key (kbd "C-x r C-y") 'yank-replace-rectangle)
#+END_SRC

Open a numbered temp buffer using f12.

#+BEGIN_SRC emacs-lisp :tangle yes :exports code
(global-set-key (kbd "<f12>") 'ry/open-temp-buffer)
#+END_SRC

I don't use tags so I have taken the M-. binding for find-funtion-at-point.

#+BEGIN_SRC emacs-lisp :tangle yes :exports code
(global-set-key (kbd "M-.") 'find-function-at-point)
#+END_SRC

Found this handy function here:  [[http://writequit.org/org/]]

#+BEGIN_SRC emacs-lisp :tangle yes :exports code
(defun number-rectangle (start end format-string from)
  "Delete (don't save) text in the region-rectangle, then number it."
  (interactive
   (list (region-beginning) (region-end)
         (read-string "Number rectangle: "
                      (if (looking-back "^ *") "%d. " "%d"))
         (read-number "From: " 1)))
  (save-excursion
    (goto-char start)
    (setq start (point-marker))
    (goto-char end)
    (setq end (point-marker))
    (delete-rectangle start end)
    (goto-char start)
    (loop with column = (current-column)
          while (and (<= (point) end) (not (eobp)))
          for i from from   do
          (move-to-column column t)
          (insert (format format-string i))
          (forward-line 1)))
  (goto-char start))
#+END_SRC

I program most of the time.  Moving to the beginning of the means moving to the first non-whitepace character instead of moving to the true beginning on the line.  This was taken from the Prelude configuration.

#+BEGIN_SRC emacs-lisp :tangle yes :exports code
(defun prelude-move-beginning-of-line (arg)
  "Move point back to indentation of beginning of line.

Move point to the first non-whitespace character on this line.
If point is already there, move to the beginning of the line.
Effectively toggle between the first non-whitespace character and
the beginning of the line.

If ARG is not nil or 1, move forward ARG - 1 lines first. If
point reaches the beginning or end of the buffer, stop there."
  (interactive "^p")
  (setq arg (or arg 1))

  ;; Move lines first
  (when (/= arg 1)
    (let ((line-move-visual nil))
      (forward-line (1- arg))))

  (let ((orig-point (point)))
    (back-to-indentation)
    (when (= orig-point (point))
      (move-beginning-of-line 1))))

(global-set-key [remap move-beginning-of-line] 'prelude-move-beginning-of-line)
#+END_SRC

Small function to remove all ^M characters from a file.  Taken from http://www.archivum.info/comp.emacs/2007-06/00348/Re-Ignore-%5EM-in-mixed-%28LF-and-CR+LF%29-line-ended-textfiles.html

#+BEGIN_SRC emacs-lisp :tangle yes :exports code
(defun hide-dos-eol ()
  "Do not show ^M in files containing mixed UNIX and DOS line endings."
  (interactive)
  (setq buffer-display-table (make-display-table))
  (aset buffer-display-table ?\^M []))
#+END_SRC

Small function to replace the current character with another character.  This is bound in god mode so it doesn't need to be disabled.

#+BEGIN_SRC emacs-lisp :tangle yes :exports code
(defun ry/replace-character-at-point (new-char)
  "Replace the character at point in the same way that the command works in vim"
  (interactive "c")
  (delete-char 1)
  (insert new-char))
#+END_SRC

Helper for copying a rectangle.  Taken from http://www.emacswiki.org/emacs/RectangleCommands

#+BEGIN_SRC emacs-lisp :tangle yes :exports code
(defun my-copy-rectangle (start end)
  "Copy the region-rectangle instead of `kill-rectangle'."
  (interactive "r")
  (setq killed-rectangle (extract-rectangle start end)))
#+END_SRC

Helper for replacing/yanking one rectangle with another.  Taken from http://www.emacswiki.org/emacs/RectangleCommands  

#+BEGIN_SRC emacs-lisp :tangle yes :exports code
(defun yank-replace-rectangle (start end)
  "Similar like yank-rectangle, but deletes selected rectangle first."
  (interactive "r")
  (delete-rectangle start end)
  (pop-to-mark-command)
  (yank-rectangle))
#+END_SRC

I have to copy columns from emacs and past them into Emacs often enough that a function is helpful.  It extracts the rectangular region, yanks the rectangle into a temp buffer, and then copies the contents of the temp bugger into the clipboard.  The regular rectangle commands create a list of strings which is not so helpful outside of emacs.

#+BEGIN_SRC emacs-lisp :tangle yes :exports code
(defun ry/copy-rectangle (beg end)
  "Copy a rectangle as plain text, instead of a list of strings, 
that can then be pasted in another program."
  (interactive "r")
  (let ((killed-rectangle (extract-rectangle beg end)))
    (with-temp-buffer
      (insert (s-join "\n" killed-rectangle))          
      (kill-region (point-min) (point-max)))))
#+END_SRC

Helper to open a numbered temp buffer using a number and the f12 key.

#+BEGIN_SRC emacs-lisp :tangle yes :exports code
(defun ry/open-temp-buffer (&optional num)
  "Open a numbered *TEMP#* buffer based on argument."
  (interactive "p")
  (switch-to-buffer
   (format "*TEMP%d*" num))
  (god-local-mode 1))
#+END_SRC

I'm not fond of the usual =zap-to-char= behavior, so use =zap-up-to-char= instead.  It is not autoloaded.

#+BEGIN_SRC emacs-lisp :tangle yes :exports code
(use-package misc
  :bind (("M-z" . zap-up-to-char)
         ("M-Z" . zap-to-char)))
#+END_SRC

Enable the use of multiple cursors.  This is a fantastic package that gets a lot of use in my work.  People think you are a wizard when they see you editing multiple lines/places at once.  Similar to macros but easier to visualize.

#+BEGIN_SRC emacs-lisp :tangle yes :exports code
(use-package multiple-cursors
  :ensure t
  :bind (("C-S-s C-S-s" . mc/edit-lines)
         ("C->" . mc/mark-next-symbol-like-this)
         ("C-<" . mc/mark-previous-like-this)
         ("C-c *" . mc/mark-all-like-this)))
#+END_SRC

Visual way to unto changes.

#+BEGIN_SRC emacs-lisp :tangle yes :exports code
(use-package undo-tree
  :ensure t
  :diminish undo-tree-mode
  :bind (("C-x u" . undo-tree-visualize)
         ("C-/" . undo-tree-undo))  
  :config
  (progn
    (global-undo-tree-mode)
    (setq undo-tree-visualizer-timestamps t
          undo-tree-visualizer-diff t)))
#+END_SRC

A very helpful package for expanding the current region by semantic units.  

#+BEGIN_SRC emacs-lisp :tangle yes :exports code
(use-package expand-region
  :ensure t
  :bind (("C-=" . er/expand-region)))
#+END_SRC

This package makes commands work differently based on if a region is selected or not.

#+BEGIN_SRC emacs-lisp :tangle yes :exports code
(use-package whole-line-or-region
  :ensure t
  :diminish whole-line-or-region-mode
  :config
  (whole-line-or-region-mode))
#+END_SRC

Text manipulation helpers.  Need to do some more research on this.  Cannot remember why I added this package.  Could be for the transpose command.

#+BEGIN_SRC emacs-lisp :tangle yes :exports code
(use-package move-text
  :ensure t
  :disabled t)
#+END_SRC

I like to know where column 80 is.  This used to be a big deal years ago and is not so much an issue now but I sill like to know where it is in the rare event that I need to print a listing.

#+BEGIN_SRC emacs-lisp :tangle yes :exports code
(use-package fill-column-indicator
  :ensure t
  :commands (fci-mode)
  :config
  (progn    
    (defun sanityinc/fci-enabled-p () (symbol-value 'fci-mode))
    
    (defvar sanityinc/fci-mode-suppressed nil)
    (make-variable-buffer-local 'sanityinc/fci-mode-suppressed)
    
    (defadvice popup-create (before suppress-fci-mode activate)
      "Suspend fci-mode while popups are visible"
      (let ((fci-enabled (sanityinc/fci-enabled-p)))
        (when fci-enabled
          (setq sanityinc/fci-mode-suppressed fci-enabled)
          (turn-off-fci-mode))))
    
    (defadvice popup-delete (after restore-fci-mode activate)
      "Restore fci-mode when all popups have closed"
      (when (and sanityinc/fci-mode-suppressed
                 (null popup-instances))
        (setq sanityinc/fci-mode-suppressed nil)
        (turn-on-fci-mode)))

    (setq fci-rule-column 80)
    (turn-on-fci-mode)))
#+END_SRC

* Spelling
** Configuration

I am very poor at spelling.  The following will enable flyspell and use Hunspell as the background spelling process.  The dictionary and Hunspell are installed below my home directory on my Windows machines.

#+BEGIN_SRC emacs-lisp :tangle yes :exports code  
(setq ispell-personal-dictionary "~/emacs/Config/en_US_personal"
      ispell-silently-savep t
      ispell-quietly t)
#+END_SRC

Flyspell will need a couple environment variables set to know what the default dictionary is and its path.  This may be done in Linux but is not done properly in Windows, so set it up here.
thsat 
#+BEGIN_SRC emacs-lisp :tangle yes :exports code  
(if (windows-p)
    (progn
      (setenv "DICTIONARY" "en_US")
      (setenv "LANG" "en_US")
      (setenv "DICPATH" "~/emacs/Hunspell/share/hunspell"))
  (progn
    (setenv "DICTIONARY" "en US")
    (setenv "DICTPATH" "/usr/share/hunspell")))
#+END_SRC

Enable spelling for comments in programming modes too.

#+BEGIN_SRC emacs-lisp :tangle yes :exports code  
(add-hook 'java-mode-hook
          #'(lambda ()
            (flyspell-prog-mode)))
            
(add-hook 'emacs-lisp-mode-hook
          #'(lambda ()
            (flyspell-prog-mode)))
#+END_SRC

This was a suggestion from [[http://www.emacswiki.org/emacs/FlySpell]] as a way to speed up flyspell by not writing messages.

#+BEGIN_SRC emacs-lisp :tangle yes :exports code   
(setq flyspell-issue-message-flag nil)
#+END_SRC

** Key bindings

#+BEGIN_SRC emacs-lisp :tangle yes :exports code 
(global-set-key (kbd "<f1>") 'ry/flyspell-check-previous-highlighted-word)
(global-set-key (kbd "<f2>") 'flyspell-correct-word-before-point)
(global-set-key (kbd "<f3>") 'ry/flyspell-check-next-highlighted-word)
(global-set-key (kbd "<f4>") 'ispell-buffer)
#+END_SRC

** Functions

This function was taken from http://www.emacswiki.org/emacs/FlySpell.  It will enable the use of a popup for flyspell instead of it's normal mode of operation.  Company uses a popup so why not have a similar behavior for Flyspell.  This could be annoying if checking a whole buffer but I usually do not check a whole buffer at once.

#+BEGIN_SRC emacs-lisp :tangle yes :exports code 
(defun flyspell-emacs-popup-textual (event poss word)
  "A textual flyspell popup menu."
  (require 'popup)
  (let* ((corrects (if flyspell-sort-corrections
                       (sort (car (cdr (cdr poss))) 'string<)
                     (car (cdr (cdr poss)))))
         (cor-menu (if (consp corrects)
                       (mapcar (lambda (correct)
                                 (list correct correct))
                               corrects)
                     '()))
         (affix (car (cdr (cdr (cdr poss)))))
         show-affix-info
         (base-menu  (let ((save (if (and (consp affix) show-affix-info)
                                     (list
                                      (list (concat "Save affix: " (car affix))
                                            'save)
                                      '("Accept (session)" session)
                                      '("Accept (buffer)" buffer))
                                   '(("Save word" save)
                                     ("Accept (session)" session)
                                     ("Accept (buffer)" buffer)))))
                       (if (consp cor-menu)
                           (append cor-menu (cons "" save))
                         save)))
         (menu (mapcar
                (lambda (arg) (if (consp arg) (car arg) arg))
                base-menu)))
    (cadr (assoc (popup-menu* menu :scroll-bar t) base-menu))))
#+END_SRC

Add a hook for the function defined above using popups for spell checking.

#+BEGIN_SRC emacs-lisp :tangle yes :exports code 
(eval-after-load "flyspell"
  '(progn
     (fset 'flyspell-emacs-popup 'flyspell-emacs-popup-textual)))
#+END_SRC

Function to check the next highlighted word.

#+BEGIN_SRC emacs-lisp :tangle yes :exports code 
(defun ry/flyspell-check-next-highlighted-word ()
  "Custom function to spell check next highlighted word"
  (interactive)
  (flyspell-goto-next-error)
  (flyspell-correct-word-before-point))
#+END_SRC

This is a slightly modified version of function with the same name from Flyspell.  It uses flyspell-correct-word-before-point instead of ispell-word so that the popup defined above will be used for corrections.

#+BEGIN_SRC emacs-lisp :tangle yes :exports code 
(defun ry/flyspell-check-previous-highlighted-word (&optional arg)
  "Correct the closer misspelled word.
This function scans a mis-spelled word before the cursor. If it finds one
it proposes replacement for that word. With prefix arg, count that many
misspelled words backwards."
  (interactive)
  (let ((pos1 (point))
	(pos  (point))
	(arg  (if (or (not (numberp arg)) (< arg 1)) 1 arg))
	ov ovs)
    (if (catch 'exit
	  (while (and (setq pos (previous-overlay-change pos))
		      (not (= pos pos1)))
	    (setq pos1 pos)
	    (if (> pos (point-min))
		(progn
		  (setq ovs (overlays-at (1- pos)))
		  (while (consp ovs)
		    (setq ov (car ovs))
		    (setq ovs (cdr ovs))
		    (if (and (flyspell-overlay-p ov)
			     (= 0 (setq arg (1- arg))))
			(throw 'exit t)))))))
	(save-excursion
	  (goto-char pos)
	  ;; (ispell-word)
      (flyspell-correct-word-before-point)
	  (setq flyspell-word-cache-word nil) ;; Force flyspell-word re-check
	  (flyspell-word))
      (error "No word to correct before point"))))
#+END_SRC

* Buffers

Enable god-mode prior to switching buffers.  This is done as I am trying to use god-mode as a poor-mans evil mode and constantly forget to switch back into god-mode.  It would probably be better to force myself to do the switching but I cannot get it.

#+BEGIN_SRC emacs-lisp :tangle yes :exports code
(defun ry/switch-buffer ()
  "Function to switch the current buffer to God-mode
 prior to switching buffers."
  (interactive)
  (god-local-mode 1)
  (helm-mini))
#+END_SRC

Two handy little functions courtesy of Sacha Chua, http://pages.sachachua.com/.emacs.d/Sacha.html.

#+BEGIN_SRC emacs-lisp :tangle yes :exports code
(defun sacha/vsplit-last-buffer (prefix)
  "Split the window vertically and display the previous buffer."
  (interactive "p")
  (split-window-vertically)
  (other-window 1 nil)
  (unless prefix
    (switch-to-next-buffer)))

(defun sacha/hsplit-last-buffer (prefix)
  "Split the window horizontally and display the previous buffer."
  (interactive "p")
  (split-window-horizontally)
  (other-window 1 nil)
  (unless prefix (switch-to-next-buffer)))
#+END_SRC

I don't use this function but am leaving it in case I do find a need for it.  Taken from http://emacsredux.com/blog/2013/03/30/kill-other-buffers/. 

#+BEGIN_SRC emacs-lisp :tangle yes :exports code
(defun kill-other-buffers ()
  "Kill all buffers but the current one.
Don't mess with special buffers."
  (interactive)
  (dolist (buffer (buffer-list))
    (unless (or (eql buffer (current-buffer)) (not (buffer-file-name buffer)))
      (kill-buffer buffer))))
#+END_SRC

When I am working it is rare that I will kill a buffer other then the currently active one.  This function will kill the current buffer without prompting me.  It was found at http://www.masteringemacs.org/articles/2014/02/28/my-emacs-keybindings/

#+BEGIN_SRC emacs-lisp :tangle yes :exports code
(defun kill-this-buffer () 
  "Kill the current buffer without prompting."  
  (interactive) 
  (kill-buffer (current-buffer)))
#+END_SRC

Bindings for custom splitting commands.

#+BEGIN_SRC emacs-lisp :tangle yes :exports code
(global-set-key (kbd "C-x 2") 'sacha/vsplit-last-buffer)
(global-set-key (kbd "C-x 3") 'sacha/hsplit-last-buffer)
#+END_SRC

Key bindings for managing the size of windows.

#+BEGIN_SRC emacs-lisp :tangle yes :exports code 
(global-set-key (kbd "S-C-<left>") 'shrink-window-horizontally)
(global-set-key (kbd "S-C-<right>") 'enlarge-window-horizontally)
(global-set-key (kbd "S-C-<down>") 'shrink-window)
(global-set-key (kbd "S-C-<up>") 'enlarge-window)
#+END_SRC

I only kill the current buffer most of the time.  The binding below is used so that I do not need to select which buffer to kill.  If I need to kill a bunch of buffers or one that is not the current one I will use helm.

#+BEGIN_SRC emacs-lisp :tangle yes :exports code
(global-set-key (kbd "C-x k") 'kill-this-buffer)
#+END_SRC

* Browsing
** Configuration

I mainly use Internet Explorer when on Windows machines so browse the current URL using it.

#+BEGIN_SRC emacs-lisp :tangle yes :exports code
(setq browse-url-browser-function 'browse-url-generic
      browse-url-generic-program (if (windows-p)
                                     "C:/Program Files/Internet Explorer/iexplore.exe"))
#+END_SRC

** Key binding

#+BEGIN_SRC emacs-lisp :tangle yes :exports code
(global-set-key (kbd "C-c B") 'browse-url-at-point)
#+END_SRC

* SQL

Work uses DB2 and DataStudio.  Opening RAD and DataStudio at the same time is a major drain on resources, especially when WAS is also running.  Instead I will stay in Emacs to do my database work.

** Setup

The code below is used to setup a few configurations based on if the client is Windows or not.  The configuration was lifted from a nice document located [[http://www.ibm.com/developerworks/data/library/techarticle/0206mathew/0206mathew.html]].

| Option | Decription                                               |
|--------+----------------------------------------------------------|
| -t     | Semicolon (;) is treated as the command line terminator. |
| +ec    | Print SQLCODE.                                           |
| +m     | Print number of rows affected by statement.              |

#+BEGIN_SRC emacs-lisp :tangle yes :exports code 
(if (windows-p)
    (progn  
      (setq sql-db2-program "C:/PROGRA~2/IBM/SQLLIB/BIN/db2cmd.exe")
      (setq sql-db2-options '("-c" "-i" "-w" "db2setcp.bat" "db2" "-tv" "-ec" "-m"))))
#+END_SRC

This list will be used to hold the SQL buffers that have the DB2 process.  I have a tendency to leave DB connections alive when I leave for the day.  These settings will keep a list of connection buffers and will close any hanging buffers at 5:00 PM.

#+BEGIN_SRC emacs-lisp :tangle yes :exports code
(setq db-buffers-list ())

(run-at-time "5 minutes" nil 'ry/sql-connection-cleanup)
#+END_SRC

Setup completion package that can be found at https://github.com/jonakand/sql-capf.git

#+BEGIN_SRC emacs-lisp :tangle yes :exports code
(use-package sql-completion
  :load-path "~/emacs/sql-capf"
  :config
  (progn
    (setq sql-completion-min-target-size 4
          sql-completion-debugging t
          completion-ignore-case t)
    
    (setq sql-find-query-tokens 'sql-db2-find-query-tokens)
    (setq sql-get-database-objects 'sql-db2-get-database-objects)
    
    (add-hook 'completion-at-point-functions 'sql-completion-at-point)))
#+END_SRC

** Key bindings

The key bindings for SQL related commands are below.  The reasoning for using C-d is because I use DB2 at work and it is eady to remember.  Previously it was bound to the F5 key as work also uses DataStudio.  All key bindings are defined in the god-mode section of this document.

| Chord       | Command                |
|-------------+------------------------|
| C-c C-d C-d | ry/sql-disconnect      |
| C-c C-d C-e | ry/sql-export-dwim     |
| C-c C-d C-o | ry/sql-open-database   |
| C-c C-d C-O | ry/sql-reopen-database |
| C-c C-d C-r | sql-send-region        |
| C-c C-d C-s | ry/sql-send-dwim       |

** Functions

Possible new conenction command setup.  This would use the sql.el framework.

#+BEGIN_SRC emacs-lisp :tangle yes :exports code
(defun ry/sql-open-database (conn)
  "Open a SQLi process for the connection provided."
  (interactive (list
                (ivy-read "Connection: " sql-connection-alist :predicate nil :require-match t)))
  (setq sql-product 'db2)
  (sql-connect conn conn)

  (let ((sql-buffer-name (concat "*SQL: " conn "*"))
        (db-buffer-name (concat "*DB: " conn "*")))
    (delete-other-windows (get-buffer-window sql-buffer-name))
    
    ;;  These will be used later to automatically disconnect from the
    ;;  database if it is left connected.  
    (set (make-local-variable 'database-conn-p) t)
    (add-to-list 'db-buffers-list (current-buffer))

    ;;  sql-mode split the frame so move to the other side, switch
    ;;  to the DB buffer, and set things up so that it will interact
    ;;  with the SQLi process.
    (split-window-horizontally)
    (other-window 1)
    (switch-to-buffer db-buffer-name)
    (sql-mode)
    (sql-set-product "db2")

    ;;  Set the buffer to send SQL queries to.
    (setq sql-buffer sql-buffer-name)))
  
(defun ry/sql-open-database-hook ()
  "Send the connection string to the SQLi process."
  (let* ((password (read-passwd "Password: ")))
    (god-local-mode)
    
    ;;  Send connection string to process.
    (sql-send-string (concat "CONNECT TO " sql-connection " USER " sql-user " USING " password ";"))))

;;  Add hook to automatically send the CONNECT string to the SQLi process.
(add-hook 'sql-login-hook
          #'ry/sql-open-database-hook)
#+END_SRC

Turn off visual line mode for sql-mode.

#+BEGIN_SRC emacs-lisp :tangle yes :exports code
(add-hook 'sql-mode-hook
          #'(lambda ()
              (visual-line-mode 0)
              (toggle-truncate-lines 1)))

(add-hook 'sql-interactive-mode-hook
          #'(lambda ()
              (visual-line-mode 0)
              (toggle-truncate-lines 1)))
#+END_SRC

Originally I was using a custom company compltion backend for completing schema name, table name, column name.  It was suggested that this be done as a completion at point function instead and then company would get it for "free" as it will use the completion at point functions.  Defining it this way is a little shorter.

#+BEGIN_SRC emacs-lisp :tangle yes :exports code
;;  Code to be added here...
#+END_SRC

Simple method to disconnect from the database currently connected to.  This assumes that the current connection matches the buffer local variable that holds the database name.

#+BEGIN_SRC emacs-lisp :tangle yes :exports code
(defun ry/sql-disconnect ()
  "Disconnect the current DB connection."
  (interactive)
  (when (and sql-buffer database-conn-p)
    (with-current-buffer sql-buffer
      (let ((conn (buffer-local-value 'sql-connection (current-buffer))))
        (sql-send-string (concat "DISCONNECT " conn ";"))
        (setq database-conn-p nil)))))
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle yes :exports code
(defun ry/sql-quit ()
  "Quit the current DB2 CLP process."
  (interactive)
  (when sql-buffer
    (with-current-buffer sql-buffer
      (let ((conn (buffer-local-value 'sql-connection (current-buffer))))
        (ry/sql-disconnect)
        (sql-send-string (concat "QUIT;"))))))
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle yes :exports code
(defun ry/sql-reopen-database (password)
  "Reconnect to the database that the current buffer was
connected to using the ry/sql-open-database command.  This
command relies on the database-name created by the other
function."
  (interactive (list (read-passwd "Password: ")))
  (when (and sql-buffer (not database-conn-p))
    (with-current-buffer sql-buffer
      (let ((conn (buffer-local-value 'sql-connection (current-buffer))))
        (sql-send-string (concat "CONNECT TO " conn " USER " sql-user " USING " password ";"))
        (setq database-conn-p t)))))
#+END_SRC

This function will be used as part of a run-at-time function.  It will look at the list of known DB2 buffers and close the related connection if it sees that the connection is still open.  There is a hole if the connection in established outside of the normal method used by me.

#+BEGIN_SRC emacs-lisp :tangle yes :exports code
(defun ry/sql-connection-cleanup ()
  (interactive)
  "This function will look for open database connections
and disconnect them.  It is assumed that a connection is
only opened by ry/sql-open-database."
  (message "Starting disconnect function: %s" (current-time-string))
  (let ((tmp-list db-buffers-list))
    (dolist (db-buffer tmp-list)
      (if (buffer-live-p db-buffer)
          (with-current-buffer db-buffer 
            (cond ((and (get-buffer-process db-buffer) database-conn-p)
                   (message "Disconnecting %s."  database-name)
                   (sql-send-string (concat "DISCONNECT " database-name ";"))
                   (setq database-conn-p nil))
                  ((not database-conn-p)
                   (message "Skipping %s as it is not connected." database-name))
                  (t nil)))
        (progn
          (message "Buffer no longer exists, removing %s." db-buffer)
          (setq db-buffers-list (delete db-buffer db-buffers-list)))))))
#+END_SRC

The method below was created because I have a tendency to forget to put a restriction on the number of rows returned by my queries.  It needs some serious TLC to get it working correctly.

#+BEGIN_SRC emacs-lisp :tangle yes :exports code
(defun ry/sql-send-dwim (beg end)
  "Send a statement to the DB2 process.
This function is a DWIM function.  If no region is active
it will select the current \"paragraph\" and send it.  If a
region is active it will send it.  Also, it will add
\"FETCH FIRST 50 ROWS ONLY WITH UR\" to the statement prior
to sending."
  (interactive 
   (if (use-region-p)
       (list (region-beginning) (region-end))
     (let ((beg (save-excursion
                  (backward-paragraph)
                  (point)))
           (end (save-excursion
                  (forward-paragraph)
                  (point))))
       (list beg end))))
  (save-restriction
    (save-excursion
      (narrow-to-region beg end)
      (goto-char (point-min))
      (when (search-forward "select" nil t)
        (let ((sql-contains-fetch (buffer-contains-substring "fetch"))
              (sql-contains-with (buffer-contains-substring "with")))
          (cond         
           ((and sql-contains-fetch (not sql-contains-with))
            (while (search-forward ";" nil t)
              (replace-match "\n  WITH UR;")))
           ((and (not sql-contains-fetch) sql-contains-with)
            (goto-char (point-min))
            (while (search-forward " with ur;" nil t)
              (replace-match "\n FETCH FIRST 50 ROWS ONLY\n  WITH UR;")))
           ((and (not sql-contains-fetch) (not sql-contains-with))
            (message "3")
            (while (search-forward ";" nil t)
              (replace-match "\n FETCH FIRST 50 ROWS ONLY\n  WITH UR;"))))))
      (sql-send-string (buffer-substring-no-properties (point-min) (point-max))))))


(defun buffer-contains-substring (string)
  "Used to tell if a given string is in the
current buffer.  Found at:
http://stackoverflow.com/questions/3034237/check-if-current-emacs-buffer-contains-a-string"
  (save-excursion
    (save-match-data
      (goto-char (point-min))
      (search-forward string nil t))))
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle yes :exports code
(defun ry/sql-send-paragraph ()
  "Add FETCH FIRST clause to the SQL statement prior to sending"
  (interactive)
  (let ((start (save-excursion
                 (backward-paragraph)
                 (point)))
        (end (save-excursion               
               (forward-paragraph)
               (point))))
    (save-restriction
      (narrow-to-region start end)
      (goto-char (point-min))
      (when (search-forward "select" nil t)       
        (cond         
         ((and (search-forward "fetch" nil t) (not (search-forward "with" nil t)))
          (while (search-forward ";" nil t)
            (replace-match " WITH UR;")))
         ((and (not (search-forward "fetch" nil t)) (search-forward "with" nil t))
          (goto-char (point-min))
          (while (search-forward " with ur;" nil t)
            (replace-match " FETCH FIRST 50 ROWS ONLY WITH UR;")))
         ((and (not (search-forward "fetch" nil t)) (not (search-forward "with" nil t)))
          (while (search-forward ";" nil t)
            (replace-match " FETCH FIRST 50 ROWS ONLY WITH UR;")))))
      (sql-send-string (buffer-substring-no-properties (point-min) (point-max))))))
#+END_SRC

I have two wrap a bunch of lines in single quotes and commas to create queries often enough that a function was needed.

#+BEGIN_SRC emacs-lisp :tangle yes :exports code
(defun ry/sql-wrap-in (beg end)
  "Wrap the active region in single quotes so that it can be used within
parentheses in the IN portion of a WHERE clause."
  (interactive "r")
  (save-restriction
    (narrow-to-region beg end)
    (goto-char (point-min))
    (while (search-forward-regexp "^\\(.*\\)$" nil t)     
      (replace-match "'\\1',"))
    (goto-char (point-max))
    (when (eq (char-before) 44)
        (delete-char -1))))
#+END_SRC

To make looking at results easier the function below can be used to convert a region into an org-mode table.  It is assumed that the first row in the region is column headings that do not contain spaces.

#+BEGIN_SRC emacs-lisp :tangle yes :exports code
(defun ry/sql-result-to-org-table (beg end)
  "Convert a DB2 result to an org-mode table."
  (interactive "r")
  (let* ((buf (current-buffer))
         (table
          (with-temp-buffer
            (insert-buffer-substring-no-properties buf beg end)
            (goto-char (point-min))

            ;;  Start processing on the line between the column headers
            ;;  and the result data.
            (forward-line)
                        
            (let* (
                   ;;  Loop over the second line in the result to get a list
                   ;;  of colunm widths to know where to insert the pipes.
                   (lengths
                    (cl-loop for p in (split-string (buffer-substring-no-properties (line-beginning-position) (line-end-position)))
                             collect (length p)))

                   ;;  Create a regular expression that will match the data
                   ;;  rows.  Each group in the expression will be replaced
                   ;;  with a pipe.
                   (regexp 
                    (cl-loop for l in lengths with r = "" do
                             (setq r (concat r ".\\{" (number-to-string l) "\\}\\([ ]*\\)"))
                             finally return r)))

              ;;  Loop over each line and replace the space between
              ;;  each column with a pipe.              
              (goto-char (point-min))
              (while (search-forward-regexp regexp nil t)
                (cl-loop for c from 1 to (length lengths) do
                         (replace-match "|" nil nil nil c)))

              ;;  Add pipes to the beginng of each line so that org-mode
              ;;  will create the result table properly.
              (goto-char (point-min))              
              (cl-loop until (eobp) do (insert-string "|") (forward-line)))            
            (buffer-substring-no-properties (point-min) (point-max)))))
    (delete-region beg end)
    (insert table)
    (org-mode)
    (org-table-align)
    (goto-char (point-min))))
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle yes :exports code
(defun ry/sql-kill-as-tab-delimited (beg end)
  "Kill the active region as a tab delimited verion of
itself.  The top line in the region is assumed to have
the column headers from a DB2 query result."
  (interactive "r")
  (let* ((buf (current-buffer))
         (table
          (with-temp-buffer
            (insert-buffer-substring-no-properties buf beg end)
            (goto-char (point-min))

            ;;  Move past the first column      
            (forward-whitespace 1)
            
            (let ((pt (point))
                  (lc (count-lines (point-min) (point-max)))
                  (d))

              ;;  Loop over each whitespace delimited column
              ;;  on the first line.
              (while (= (line-number-at-pos) 1)

                ;;  Loop over each row in the column and
                ;;  add pipes on each line.
                (while (and (<= (line-number-at-pos) lc)
                            (eq d nil))
                  (insert "|")

                  ;;  If not at the bottom of a column go
                  ;;  to the next row and backup one
                  ;;  character else set a flag to denote
                  ;;  that the bottom of a column was hit.
                  (if (/= (line-number-at-pos) lc)
                      (progn
                        (next-logical-line 1)
                        (goto-char (- (point) 1)))
                    (setq d t)))

                ;;  Go back to the top of the current column (pt),
                ;;  set pt to point to remember where the top of
                ;;  the column is, move to the next column, and
                ;;  reset the of the column flag (d).
                (goto-char pt)
                (forward-whitespace 1)
                (setq pt (point))
                (setq d nil)))

            ;;  Replace the pipes that were inserted with TAB
            ;;  characters.
            (goto-char (point-min))
            (while (search-forward-regexp "\\s-*|" nil t)
              (replace-match "\t"))
            (kill-region (point-min) (point-max)))))))
#+END_SRC

The function below is used quite often.  It is not the prettiest but it gets the job done.  It will wrap the current SQL statement in an EXPORT prior to sending.  This is helpful when I want to see a large XML document or I want to retrieve a row that exceeds the maximum number of characters that the DB2 CLP will return.

** TODO Fix waiting for export
   Fix the way that the export function waits for the SQL process to finish prior to switching to the export buffer.  Currently emacs will copy the data from the export file and paste it into the export buffer before the SQL process adds data to the file.  This results in having to close the export buffer and then visiting the file containing the exported data.

Based on searches it looks like a process filter will need to be created.  The filter should see if the output has the word export and then act accordingly or if it doesn't contain export insert the value into the process buffer.  The emacs manual has a [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Filter-Functions.html#Filter-Functions][page]] that describes what should be done if the filter is to act like the default filter.

#+BEGIN_SRC emacs-lisp :tangle yes :exports code
(defun ry/sql-export-dwim (beg end)
  "Prefix the current paragraph or region if selected
with an EXPORT command and send the paragraph to the
SQL process."
  (interactive
   (if (use-region-p)
       (list (region-beginning) (region-end))
     (let ((beg (save-excursion
                  (backward-paragraph)
                  (point)))
           (end (save-excursion
                  (forward-paragraph)
                  (point))))
       (list beg end))))
  (let ((temp-file (make-temp-file "DB2-EXPORT-" nil)))
    (sql-send-string (concat "EXPORT TO " temp-file " OF DEL MODIFIED BY COLDEL0x09 " (buffer-substring-no-properties beg end)))
    (switch-to-buffer "*EXPORT*")
    (sleep-for 1)
    (insert-file-contents-literally (concat temp-file ".001.xml"))
    (goto-char (point-min))
    (while (re-search-forward "<\\?xml version=\"1.0\" encoding=\"UTF-8\" \\?>" nil t)
      (replace-match "\n  <?xml version=\"1.0\" encoding=\"UTF-8\" ?>" nil nil))
    (goto-char (point-min))
    (kill-line)
    (goto-longest-line (point-min) (point-max))
    (let ((max-length (- (line-end-position) (line-beginning-position))))
      (goto-char (point-min))
      (setq more-lines t)
      (while more-lines
        (setq cur-length (- (line-end-position) (line-beginning-position)))
        (if (< cur-length max-length)
            (progn 
              (goto-char (line-end-position))
              (insert-char 32 (- max-length cur-length))))
        (setq more-lines (= 0 (forward-line 1)))))
    (kill-rectangle (point-min) (point-max))
    (erase-buffer)
    (insert-file-contents-literally temp-file)
    (while (re-search-forward "\"<XDS\.\*\$" nil t)
      (replace-match "" nil nil))
    (goto-char (point-min))
    (while (re-search-forward "\"" nil t)
      (replace-match "" nil nil))
    (goto-char (point-min))
    (goto-char (line-end-position))
    (yank-rectangle)
    (god-local-mode 1)))
#+END_SRC

* XML
** Key bindings

See the Hydra configuration for the key bindings for XML.

| Key     | Command                 |
|---------+-------------------------|
| C-c x f | Pretty-print XML region |
| C-c x l | Compact XML region      |
| C-c x w | Get current xpath       |
| C-c x x | Run xquery on buffer    |
| C-c x X | Run xquery on region    |

** Functions

I am a Java programmer so I created my own utility for formatting XML documents.  The listing is below.  Basically it accepts the XML document to be formatted and an optional argument to indicate if you want the compact formatting or pretty print.

#+BEGIN_SRC java :tangle no :exports code
package com.brookwood.util;

import java.io.IOException;
import java.io.StringReader;
import java.io.StringWriter;
import java.util.Scanner;

import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.parsers.ParserConfigurationException;

import org.w3c.dom.DOMConfiguration;
import org.w3c.dom.DOMImplementation;
import org.w3c.dom.Document;
import org.w3c.dom.ls.DOMImplementationLS;
import org.w3c.dom.ls.LSOutput;
import org.w3c.dom.ls.LSSerializer;
import org.xml.sax.InputSource;
import org.xml.sax.SAXException;

/*******************************************************************************
 * This class is used to format an XML document.  If the document is to be 
 * "pretty" printed the "--pretty" parameter should be passed before the document
 * to be formatted.  If the pretty flag is not set the XML will be formatted to
 * be on a single line.
 * 
 * @author Ryan Yanson
 *
 ******************************************************************************/
public class XMLFormatter {

	/***************************************************************************
	 * Main entry point for program.
	 * 
	 * @param	args The command line arguments.
	 **************************************************************************/
	public static void main(String[] args) {
		(new XMLFormatter()).run(args);
	}

	/***************************************************************************
	 * Format the XML document passed.  If the first argument is "--pretty" then
	 * format the document for printing, else format it on a single line.
	 * 
	 * @param	args The arguments passed from the command line.
	 **************************************************************************/
	private void run(String[] args) {
		Boolean doIndent = false;
		
		if (args.length >= 1) {
			doIndent = args[0].equalsIgnoreCase("--pretty") ? true : false;
		}
		
		Scanner sc = new Scanner(System.in);
		StringBuilder xml = new StringBuilder();
		
		while (sc.hasNextLine()) {
			String line = sc.nextLine();
			
			//  Remove spaces between tags.
			line = line.replaceAll(">\\s+<", "><");
			line = line.replaceAll("^\\s+<", "<");
			
			xml.append(line);
		}
		
		sc.close();
		
		System.out.print(serializeXML(createDOM(xml.toString()), doIndent));
		System.exit(0);
	}
	
	/***************************************************************************
	 * Create a W3C DOM object.
	 * 
	 * @param cissEvent The CISS event in XML format.
	 * @return a DOM object.
	 * @throws IOException
	 * @throws SAXException
	 **************************************************************************/
	public Document createDOM(String xmlString) {
		try {
			InputSource source = new InputSource(new StringReader(xmlString));
			
			DocumentBuilder builder = DocumentBuilderFactory.newInstance().newDocumentBuilder();
			return builder.parse(source);
		} catch (SAXException e) {
			System.err.println("SAXException while processing XML string : " + e.getMessage());
			System.exit(1);
		} catch (IOException e) {
			System.err.println("IOException while processing XML string : " + e.getMessage());
			System.exit(1);
		} catch (ParserConfigurationException e) {
			System.err.println("ParserConfigurationException while processing XML string : " + e.getMessage());
			System.exit(1);
		}
		
		return null;
	}
	
	/***************************************************************************
	 * Serialize an XML document for printing or onto a single line.
	 * 
	 * @param	document The document to format.
	 * @param	doIndent A Boolean indicating if pretty printing should be used.
	 * @return	The serialized XML document.
	 **************************************************************************/
	public String serializeXML(Document document, Boolean doIndent) {
		DOMImplementation domImplementation = document.getImplementation();
		
		if (domImplementation.hasFeature("LS", "3.0") && domImplementation.hasFeature("Core", "2.0")) {
			DOMImplementationLS domImplementationLS = (DOMImplementationLS) domImplementation.getFeature("LS", "3.0");
			LSSerializer lsSerializer = domImplementationLS.createLSSerializer();
			lsSerializer.setNewLine("\n");
			
			DOMConfiguration domConfiguration = lsSerializer.getDomConfig();
			
			if (domConfiguration.canSetParameter("format-pretty-print", doIndent)) {
				lsSerializer.getDomConfig().setParameter("format-pretty-print", doIndent);
				
				LSOutput lsOutput = domImplementationLS.createLSOutput();
				lsOutput.setEncoding("UTF-8");
				
				StringWriter stringWriter = new StringWriter();

				lsOutput.setCharacterStream(stringWriter);
				lsSerializer.write(document, lsOutput);
				
				return stringWriter.toString();
			} else {
				throw new RuntimeException("DOMConfiguration 'format-pretty-print' parameter isn't settable.");
			}
		} else {
			throw new RuntimeException("DOM 3.0 LS and/or DOM 2.0 Core not supported.");
		}
	}
	
}
#+END_SRC

Pretty-print the selected region, or buffer if no active region, using the Java utility defined above.

#+BEGIN_SRC emacs-lisp :tangle yes :exports code
(defun ry/xml-format (beg end)
  "Call an external Java program to pretty print the
current region or the current buffer if no region is
active."
  (interactive
   (if (use-region-p)
       (list (region-beginning) (region-end))
     (list (point-min) (point-max))))
  (save-excursion
    (shell-command-on-region beg end "java -jar H:/emacs/Java/XMLFormatter.jar --pretty" (current-buffer) t)))
#+END_SRC

The following Java program is used to generate a list of xpaths for the document in the current region.

#+BEGIN_SRC java :tangle no :exports code
package com.brookwood.util;

import java.io.StringReader;

import javax.xml.parsers.SAXParser;
import javax.xml.parsers.SAXParserFactory;

import org.xml.sax.InputSource;
import org.xml.sax.XMLReader;

/*******************************************************************************
 * Small utility to generate Xpaths for the XML document passed.  The code to
 * do this was written by Blaise Doughan and found on StackOverflow.
 * 
 * http://stackoverflow.com/a/4783172/6735702
 *
 ******************************************************************************/
public class XpathGen {

    /***************************************************************************
     * Main driver.  Accept args and pass it on to the main process.
     * 
     * @param args the arguments passed to the program.
     * @throws Exception when something goes wrong.
     **************************************************************************/
	public static void main(String[] args) throws Exception {	 
		new XpathGen().doWork(args);
	}

	/***************************************************************************
	 * Main processing to generate XPATHs from input String.
	 * 
	 * @param args arguments passed to the program.
	 * @throws Exception when something goes wrong.
	 **************************************************************************/
	private void doWork(String[] args) throws Exception {
	    if (args.length < 1) {
	        System.err.println("Usage: XpathGen <XML_DOCUMENT>");
	        System.exit(1);
	    }
	    
		SAXParserFactory spf = SAXParserFactory.newInstance();
		SAXParser sp = spf.newSAXParser();
		XMLReader xr = sp.getXMLReader();
		
		StringReader sr = new StringReader(args[0]);

		xr.setContentHandler(new FragmentContentHandler(xr));
		xr.parse(new InputSource(sr));
		
		System.exit(0);
	}

}
#+END_SRC

Handler for the xpath generation class above.

#+BEGIN_SRC java :tangle no :exports code
package com.brookwood.util;

import java.util.HashMap;
import java.util.Map;

import org.xml.sax.Attributes;
import org.xml.sax.SAXException;
import org.xml.sax.XMLReader;
import org.xml.sax.helpers.DefaultHandler;

/*******************************************************************************
 * Small utility to generate Xpaths for the XML document passed.  The code to
 * do this was written by Blaise Doughan and found on StackOverflow.
 * 
 * http://stackoverflow.com/a/4783172/6735702
 *
 ******************************************************************************/
public class FragmentContentHandler extends DefaultHandler {

    private String xPath = "/";
    private XMLReader xmlReader;
    private FragmentContentHandler parent;
    private StringBuilder characters = new StringBuilder();
    private Map<String, Integer> elementNameCount = new HashMap<String, Integer>();

    public FragmentContentHandler(XMLReader xmlReader) {
        this.xmlReader = xmlReader;
    }

    private FragmentContentHandler(String xPath, XMLReader xmlReader, FragmentContentHandler parent) {
        this(xmlReader);
        this.xPath = xPath;
        this.parent = parent;
    }

    @Override
    public void startElement(String uri, String localName, String qName, Attributes atts) throws SAXException {
        Integer count = elementNameCount.get(qName);
        if(null == count) {
            count = 1;
        } else {
            count++;
        }
        elementNameCount.put(qName, count);
        String childXPath = xPath + "/" + qName + "[" + count + "]";

        int attsLength = atts.getLength();
        for(int x=0; x<attsLength; x++) {
            System.out.println(childXPath + "[@" + atts.getQName(x) + "='" + atts.getValue(x) + "']");
        }

        FragmentContentHandler child = new FragmentContentHandler(childXPath, xmlReader, this);
        xmlReader.setContentHandler(child);
    }

    @Override
    public void endElement(String uri, String localName, String qName) throws SAXException {
        String value = characters.toString().trim();
        if(value.length() > 0) {
            System.out.println(xPath + "='" + characters.toString() + "'");
        }
        xmlReader.setContentHandler(parent);
    }

    @Override
    public void characters(char[] ch, int start, int length) throws SAXException {
        characters.append(ch, start, length);
    }

}
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle yes :exports code
(defun ry/xml-xpath-gen (beg end)
  "Call an external Java program to generate a
list of xpaths for the document in the current
region."
  (interactive
   (if (use-region-p)
       (list (region-beginning) (region-end))
     (list (point-min) (point-max))))
  (save-excursion
    (let ((com (concat "java -jar H:/emacs/Java/XpathGen.jar \""
                       (s-replace-all '(("\"" . "'")) (buffer-substring-no-properties beg end))
                       "\"")))
      (shell-command com))))
#+END_SRC

Compact the XML document in the active region, or buffer if no active region, using the Java utility defined above.

#+BEGIN_SRC emacs-lisp :tangle yes :exports code
(defun ry/xml-linearlize (beg end)
  "Call an external Java program to linearlize the current region.  
Region needs to contain a valid XML document."
  (interactive
   (if (use-region-p)
       (list (region-beginning) (region-end))
     (list (point-min) (point-max))))  
  (save-excursion
    (shell-command-on-region beg end "java -jar H:/emacs/Java/XMLFormatter.jar " (current-buffer) t)))
#+END_SRC

I work with a lot of XML documents.  Most of the time I can just look at the document and see what I need.  Occasionally it can be helpful to write an Xquery to explore the document.  The code below is a modified version of the functions provided on http://donnieknows.com/blog/hacking-xquery-emacs-berkeley-db-xml.  While the article uses Berkley DB XML I opted to use Saxon.  Saxon is easy to obtain and the installation is simply unzipping a file and placing a JAR where I want.  This works well on work machines.

As with the other two XML related functions above this will work on a region or the whole document if no region is selected.

#+BEGIN_SRC emacs-lisp :tangle yes :exports code
(defun ry/xquery (beg end)
  "Perform Xquery using Saxon with the current region."
  (interactive
   (if (use-region-p)
       (list (region-beginning) (region-end))
     (list (point-min) (point-max))))  
  (let ((newbuffer nil)
        (buffer (get-buffer "xquery-result"))
        (xquery (buffer-substring beg end)))
    (setq xquery-result
          (cond
           ((buffer-live-p buffer) buffer)
           (t (setq newbuffer t) (generate-new-buffer "xquery-result"))))
    (with-current-buffer xquery-result
      (with-timeout
          (10 (insert "Gave up because query was taking too long."))
        (erase-buffer)
        (insert (ry/perform-xquery xquery t)))
      (nxml-mode)
      (goto-char (point-min)))
    (switch-to-buffer-other-window xquery-result)
    (other-window -1)))

(defun ry/perform-xquery (xquery &optional timed)
  "Perform the selected Xquery using Saxon."
  (setq file (make-temp-file "elisp-dbxml-"))
  (write-region xquery nil file)
  (setq result (shell-command-to-string
                (concat "java -cp H:/emacs/Java/saxon9he.jar net.sf.saxon.Query -q:\"" file "\" !indent=yes\n")))
  (delete-file file)
  (concat "" result))
#+END_SRC

This function is a modified version of the function found at http://www.emacswiki.org/emacs/NxmlMode#toc11.  In addition to displaying the current xpath in the echo area it will be copied to the clipboard.  This has proven to be useful many times when someone asks me for the xpaths for all tags in a document.  It can be added to a macro to generate the list automatically.

#+BEGIN_SRC emacs-lisp :tangle yes :exports code
(defun ry/xml-where ()
  "Display the hierarchy of XML elements the point is on as a path."
  (interactive)
  (let ((path nil))
    (save-excursion
      (save-restriction
        (widen)
        (while (and (< (point-min) (point)) ;; Doesn't error if point is at beginning of buffer
                    (condition-case nil
                        (progn
                          (nxml-backward-up-element) ; always returns nil
                          t)
                      (error nil)))
          (setq path (cons (xmltok-start-tag-local-name) path)))
        (kill-new (format "/%s" (mapconcat 'identity path "/")))
        (message "XPath copied: %s" (mapconcat 'identity path "/"))))))
#+END_SRC

Macro for unescaping double quotes in an XML document.  This should be temporary until I have time to write a function as this is hard to read.

#+BEGIN_SRC emacs-lisp :tangle yes :exports code
(fset 'ry/xml-escape-quotes
   (lambda (&optional arg) "Keyboard macro." (interactive "p") (kmacro-exec-ring-item (quote ([134217765 92 34 return 34 return 33 1] 0 "%d")) arg)))
#+END_SRC

** NXML

Use the fantastic NXML mode for XML editing.

#+BEGIN_SRC emacs-lisp :tangle yes :exports code
(use-package nxml-mode
  :commands nxml-mode
  :config
  (progn
    (setq nxml-child-indent 2)
    (setq nxml-attribute-indent 4)
    (setq nxml-auto-insert-xml-declaration-flag nil)
    (setq nxml-slash-auto-complete-flag t)))
#+END_SRC

* Narrow and widen

This function narrows and widens intelligently.  This amazingly handy bit of code was found here: [[http://endlessparentheses.com/emacs-narrow-or-widen-dwim.html]].

#+BEGIN_SRC emacs-lisp :tangle yes :exports code
(defun narrow-or-widen-dwim (p)
  "Widen if buffer is narrowed, narrow-dwim otherwise.
Dwim means: region, org-src-block, org-subtree, or defun,
whichever applies first. Narrowing to org-src-block actually
calls `org-edit-src-code'.

With prefix P, don't widen, just narrow even if buffer is
already narrowed."
  (interactive "P")
  (declare (interactive-only))
  (cond ((and (buffer-narrowed-p) (not p)) (widen))
        ((region-active-p)
         (narrow-to-region (region-beginning) (region-end)))
        ((derived-mode-p 'org-mode)
         ;; `org-edit-src-code' is not a real narrowing
         ;; command. Remove this first conditional if you
         ;; don't want it.
         (cond ((ignore-errors (org-edit-src-code))
                (delete-other-windows))
               ((ignore-errors (org-narrow-to-block) t))
               (t (org-narrow-to-subtree))))
        ((derived-mode-p 'latex-mode)
         (LaTeX-narrow-to-environment))
        (t (narrow-to-defun))))

;; (define-key endless/toggle-map "n" #'narrow-or-widen-dwim)

;; This line actually replaces Emacs' entire narrowing
;; keymap, that's how much I like this command. Only copy it
;; if that's what you want.
(define-key ctl-x-map "n" #'narrow-or-widen-dwim)

(add-hook 'LaTeX-mode-hook
          #'(lambda () (define-key LaTeX-mode-map "\C-xn" nil)))

(eval-after-load 'org-src
  '(define-key org-src-mode-map
     "\C-x\C-s" #'org-edit-src-exit))
#+END_SRC          

* Current file path

This little function has proven to be very helpful.  It's not used often but when I need the current path it makes it easy to get it.  It was originally found in Xah Lee's site and modified slightly to get the full path and file named from a dired buffer.

#+BEGIN_SRC emacs-lisp :tangle yes :exports code
(defun ry/copy-file-path (&optional dir-path-only-p)
  "Copy the current buffer's file path or dired path to `kill-ring'.
If `universal-argument' is called, copy only the dir path.  This is 
a modified version of the one created by Xah.
URL `http://ergoemacs.org/emacs/emacs_copy_file_path.html'"
  (interactive "P")
  (let ((fPath
         (if (equal major-mode 'dired-mode)
             (dired-get-filename)
           (buffer-file-name))))
    (kill-new
     (if (equal dir-path-only-p nil)
         fPath
       (file-name-directory fPath)))
    (message "File path copied: %s" fPath)))
#+END_SRC

* Launching Windows programs

The following functions were created as an easy way to launch a couple Windows programs.  I usually forget they are in here though.

#+BEGIN_SRC emacs-lisp :tangle yes :exports code
(defun ry/launch-windows-explorer ()
  "Open Windows explorer."
  (interactive)
  (if (windows-p)
      (shell-command "explorer.exe")
    (error "This command can only be used on Windows.")))

(defun ry/launch-internet-explorer ()
  "Open Internet Explorer."
  (interactive)
  (if (windows-p)      
      (shell-command "C:/Progra~1/Intern~1/iexplore.exe https://www.bing.com")
    (error "This command can only be used on Windows.")))
#+END_SRC

* Dates

Working with dates is a pain.  This group consists of a few helper functions.

#+BEGIN_SRC emacs-lisp :tangle yes :export code 
(defun ry/convert-us-to-iso-date (beg end)
  "Convert a US date to ISO format."
  (interactive "r")
  (let* ((old-date (buffer-substring-no-properties beg end))
         (new-date))
    (string-match "\\([0-9]\\{2\\}\\)/\\([0-9]\\{2\\}\\)/\\([0-9]\\{4\\}\\)" old-date)
    (setq new-date (concat (match-string 3 old-date) "-" (match-string 1 old-date) "-" (match-string 2 old-date)))
    (delete-region beg end)
    (insert new-date)))
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle yes :export code 
(defun ry/convert-iso-to-us-date (beg end)
  "Convert an ISO date to US format."
  (interactive "r")
  (let* ((old-date (buffer-substring-no-properties beg end))
         (new-date))
    (string-match "\\([0-9]\\{4\\}\\)-\\([0-9]\\{2\\}\\)-\\([0-9]\\{2\\}\\)" old-date)
    (setq new-date (concat (match-string 2 old-date) "/" (match-string 3 old-date) "/" (match-string 1 old-date)))
    (delete-region beg end)
    (insert new-date)))
#+END_SRC

* Dired

Kill buffers for dired mode and package menu mode instead of burying them.  Taken from : https://github.com/mwfogleman/config/blob/master/home/.emacs.d/michael.org

#+BEGIN_SRC emacs-lisp :tangle yes :exports code
(use-package package
  :bind (:map package-menu-mode-map
              ("q" . kill-this-buffer)))
#+END_SRC

Some additional features loaded by dired+ if running on a Windows machine.

#+BEGIN_SRC emacs-lisp :tangle yes :exports code
(use-package w32-browser
  :ensure t)
#+END_SRC

Some basic dired configuration.  Make dired stop creating buffers for each directory.  Make =q= kill the buffer instead of burying it.  List directories first.  Lastly omit the =.= and =..= lines from the listing.

#+BEGIN_SRC emacs-lisp :tangle yes :exports code
(use-package dired+
  :ensure t
  :bind (:map dired-mode-map
              ("q" . kill-this-buffer))
  :commands (dired)
  :init
  (progn   
    (diredp-toggle-find-file-reuse-dir 1)
    (add-to-list 'load-path "~/.emacs.d/extra")
    (setq ls-lisp-dirs-first t)
    (setq-default dired-omit-mode t)
    (setq-default dired-omit-files "^\\.$\\|^\\.\\.$")
    (add-hook 'dired-mode-hook 'auto-revert-mode)
    (add-hook 'dired-mode-hook #'hl-line-mode)))
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle yes :exports code
(use-package dired-quick-sort
  :ensure t
  :disabled t
  :config
  (dired-quick-sort-setup)
  (setq insert-directory-program "ls")
  (setq ls-lisp-use-insert-directory-program nil))
#+END_SRC

Enable narrowing in dired buffers to help hide uninteresting files.

#+BEGIN_SRC emacs-lisp :tangle yes :exports code
(use-package dired-narrow
  :ensure t
  :bind (:map dired-mode-map
              ("/" . dired-narrow)))
#+END_SRC

Make dired show human readable file sizes.

#+BEGIN_SRC emacs-lisp :tangle yes :exports code
(setq dired-listing-switches "-alh")
#+END_SRC

* Eshell

I use eshell to have a decent shell when on Windows machines at work.  Not much work is done in it, so most of the settings come from: https://www.masteringemacs.org/article/complete-guide-mastering-eshell.

#+BEGIN_SRC emacs-lisp :tangle yes :exports code
(use-package eshell
  :commands (eshell)
  :config
  (use-package em-smart)  
  
  (defalias 'emacs 'find-file)
  (defalias 'ec 'find-file)
  
  (setq eshell-where-to-jump 'begin
        eshell-review-quick-commands nil
        eshell-smart-space-goes-to-end t
        eshell-plain-echo-behavior t
        eshell-history-size 350
        eshell-buffer-maximum-lines 12000)
  
  (setq eshell-visual-commands '("vi" "screen" "top" "less" "more" "lynx"
                                 "ncftp" "pine" "tin" "trn" "elm" "vim"
                                 "nmtui" "alsamixer" "htop" "el" "elinks"))
  
  (setq eshell-visual-subcommands '(("git" "log" "diff" "show")))
  
  (add-hook 'eshell-mode-hook 'eshell-smart-initialize))
#+END_SRC

* Ediff

  #+BEGIN_SRC emacs-lisp :tangle yes :exports code
  (use-package ediff
    :commands (ediff-buffers ediff-files)
    :config
    (progn
      (setq ediff-split-window-function 'split-window-horizontally
            ediff-diff-options "-w")))
  #+END_SRC

* BBDB

Add BBDB configuration primarily for use with Gnus.

#+BEGIN_SRC emacs-lisp :tangle yes :exports code
(use-package bbdb
  :ensure t
  ;;:if (not(at-work-p))
  :config
  (progn
    (bbdb-initialize 'gnus 'message)
    (bbdb-mua-auto-update-init 'gnus 'message)

    ;; Look at all emails not just the first one.
    (setq bbdb-message-all-addresses t)    

    ;; use ; on a message to invoke bbdb interactively
    (setq bbdb-mua-update-interactive-p '(query . create))
    
    (add-hook
     'gnus-summary-mode-hook
     #'(lambda () (define-key gnus-summary-mode-map (kbd ";") 'bbdb-mua-edit-field)))

    (setq bbdb-file "~/.emacs.d/bbdb"
          bbdb-mail-user-agent 'gnus-user-agent  ;;  Tell BBDB which agent is being used.
          ;;bbdb-complete-name-full-completion t
          bbdb-completion-list 'primary-or-name  ;;
          bbdb-complete-mail-allow-cycling t     ;;
          bbdb-mua-pop-up nil                    ;;  Don't show popup when adding addresses.
          bbdb-pop-up-window-size 6
          bbdb-mua-pop-up-window-size 6
          ;; bbdb-offer-save 1
          ;; bbdb-use-pop-up t
          ;; bbdb-electric-p t
          ;; bbdb-popup-target-lines 1
          ;; bbdb/mail-auto-create-p t
          bbdb-update-records-p 'create          ;;  Automaticcaly create new entries.
          bbdb-ignore-message-alist '(("From" . "@postmaster.twitter.com")
                                    ("From" . "plus.google.com")
                                    ("From" . "nothome.com")
                                    ("From" . "newsletters")
                                    ("From" . "Mail Delivery System")
                                    ("From" . "mailer-daemon")
                                    ("From" . "facebookmail.com")
                                    ("From" . "noreply")
                                    ("From" . "no-reply")
                                    ("From" . "donotreply")
                                    ("From" . "emacs-orgmode")
                                    ("From" . "emacs-devel")
                                    ("Subject" . "SPAM")
                                    ("X-Spam-Level" . "*")))))
#+END_SRC

* Gnus
** Setup

  1. Download GNUTls from [[http://sourceforge.net/projects/ezwinports/]].
    - Unpack the files and place them on the PATH.  Put the dlls in the bin folder alongside the emacs executables.
  2. Automatically generated CA certificates converted from Mozilla.org can be gotten from [[http://curl.haxx.se/docs/caextract.html][curl.haxx.se]].
    - Download the CRT file from [[https://raw.githubusercontent.com/bagder/ca-bundle/master/ca-bundle.crt]].
    - Download the PEM file from [[http://curl.haxx.se/ca/cacert.pem]].
  3. Place the dlownloaded files in [[~/.emacs.d/certificates]].
  4. Add the following code to get GNUTls to work.
  
Place the following contents in [[~/.emacs.d/.authinfo]]
  
  #+BEGIN_SRC sh :exports code
  machine imap.gmail.com login XXXXX@gmail.com password <PASSWORD>
  machine imap.gmail.com login XXXXX@gmail.com password <PASSWORD> port 993
  machine imap-mail.outlook.com login XXXXX@outlook.com password <PASSWORD> port 993
  machine smtp-mail.outlook.com login XXXXX@outlook.com passowrd <PASSWORD> port 587
  #+END_SRC
  
** Configuration

Emacs config, adapted from [[https://github.com/redguardtoo/mastering-emacs-in-one-year-guide/blob/master/gnus-guide-en.org]].
  
  #+BEGIN_SRC emacs-lisp :tangle yes :exports code
  (eval-after-load "gnutls"
    '(progn
       (setq gnutls-trustfiles '("c:/Users/ryans_000/AppData/Roaming/.emacs.d/ca-bundle.crt" "c:/Users/ryans_000/AppData/Roaming/.emacs.d/cacert.pem"))))

  (use-package gnus
    :if (not(at-work-p))
    :config
    (progn
      (setq gnus-select-method '(nntp "news.gmane.org"))

      ;;Add the secondary select methods for email accounts.  In this case Gmail and Outlook using IMAP.
      ;; (add-to-list 'gnus-secondary-select-methods
      ;;              '(nnimap "gmail"
      ;;                       (nnimap-address "imap.gmail.com")
      ;;                       (nnimap-server-port 993)
      ;;                       (nnimap-stream ssl)
      ;;                       (nnir-search-engine imap)))

      (add-to-list 'gnus-secondary-select-methods
                   '(nnimap "outlook"
                            (nnimap-address "imap-mail.outlook.com")
                            (nimap-server-port 993)
                            (nnimap-stream ssl)
                            (nnir-search-engine imap)))

      (setq gnus-thread-sort-functions
            '((not gnus-thread-sort-by-date)
              (not gnus-thread-sort-by-number)))

      ;;When I expire a message I want it to immediately move to the Trash/Deleted folder.

      (setq nnmail-expiry-target 'ry/gnus-fancy-expire)
      (setq nnmail-expiry-wait 'immediate)

      (defun ry/gnus-fancy-expire (group-name)
        "Determine which expiry target should use for a given message."
        (interactive)  
        (if (s-contains-p "INBOX" group-name)      
            (format "nnimap+gmail:[Gmail]/Trash")    
          (format "nnimap+outlook:Deleted")))

      ;;  Use caching to the max.
      (setq gnus-use-cache t)

      ;;  Use tree view for groups.
      (add-hook 'gnus-group-mode-hook 'gnus-topic-mode)

      ;;  Enable threading with full display of subtrees.
      (setq gnus-summary-thread-gathering-function 'gnus-gather-threads-by-subject)

      ;;  Personal information.
      (setq user-full-name "Ryan Yanson"
            user-mail-address "ryanson@outlook.com")

      ;;  The next setting was found on [[http://www.gnu.org/software/emacs/manual/html_node/gnus/FAQ-9_002d2.html]].  Seeing as I don't care about CJK characters it's set.
      (setq gnus-use-correct-string-widths nil)

      ;;  Setup faces for the summary buffer.
      (copy-face 'font-lock-negation-char-face 'gnus-face-5)
      (setq gnus-face-5 'gnus-face-5)

      (copy-face 'font-lock-comment-face 'gnus-face-6)
      (setq gnus-face-6 'gnus-face-6)

      (copy-face 'font-lock-builtin-face 'gnus-face-7)
      (setq gnus-face-7 'gnus-face-7)

      (copy-face 'font-lock-warning-face 'gnus-face-8)
      (setq gnus-face-8 'gnus-face-8)

      ;;  Customize the formatting found in the summary buffer.
      (setq-default
       gnus-summary-line-format "%U%R%z %7{%} %5{%&user-date;%} %7{%} %8{%-30,30f%} %7{%} %B%6{%-80,80s%}\n"
       gnus-user-date-format-alist '((t . "%Y-%m-%d %H:%M"))
       gnus-summary-thread-gathering-function 'gnus-gather-threads-by-references
       gnus-thread-sort-functions '(gnus-thread-sort-by-most-recent-number)
       gnus-article-sort-functions '(gnus-article-sort-by-most-recent-number)
       gnus-sum-thread-tree-false-root " "
       gnus-sum-thread-tree-indent " "
       gnus-sum-thread-tree-leaf-with-other " "
       gnus-sum-thread-tree-root " "
       gnus-sum-thread-tree-single-leaf " "
       gnus-sum-thread-tree-vertical ""
       gnus-group-line-format "%M%S%p%P[%5y] :%B%(%uG%)\n")

      ;;  Customize the formatting in the group buffer.  I don't like to see the ugly names for the groups so they are mapped to shorter names.
      (setq-default gnus-group-line-format "%M%S%p%P[%5y] :%B%(%uG%)\n")

      (defun gnus-user-format-function-G (arg)
        "Formatting function for formatting group names nicely."
        (let ((mapped-name (assoc gnus-tmp-group group-name-map)))
          (if (null mapped-name)
              gnus-tmp-group
            (cdr mapped-name))))
                                      
      (setq group-name-map '(
                             ;;("nnimap+gmail:INBOX" . "Gmail/Inbox")
                             ;; ("nnimap+gmail:[Gmail]/All Mail" . "Gmail/All")
                             ;; ("nnimap+gmail:[Gmail]/Spam" . "Gmail/Spam")
                             ;; ("nnimap+gmail:[Gmail]/Starred" . "Gmail/Starred")
                             ;; ("nnimap+gmail:[Gmail]/Trash" . "Gmail/Trash")
                             ;; ("nnimap+gmail:jonakand@nycap.rr.com". "Gmail/Jonakand@nycap.rr.com")
                             ("nnimap+outlook:@Gmail" . "Outlook/Gmail")
                             ("nnimap+outlook:Inbox" . "Outlook/Inbox")
                             ("nnimap+outlook:Deleted" . "Outlook/Deleted")
                             ("nnimap+outlook:Macys" . "Outlook/Macys")
                             ("nnimap+outlook:Amazon" . "Outlook/Amazon")
                             ("nnimap+outlook:Bills" . "Outlook/Bills")
                             ("nnimap+outlook:Sent" . "Outlook/Sent")))

      ;;    (setq mm-text-html-renderersh 'r)
      (setq gnus-inhibit-images nil)

      (setq mm-attachment-override-types '("image/.*"))
      (setq mm-discouraged-alternatives '("text/html" "text/richtext"))

      ;;  Configure outgoing email.
      ;; (setq message-send-mail-function 'smtpmail-send-it
      ;;       smtpmail-default-smtp-server "smtp-mail.outlook.com"
      ;;       smtpmail-smtp-service 587
      ;;       smtpmail-local-domain "brookwood.com")

      (setq gnus-always-read-dribble-file t)

      ;;  Check for new mail every five minutes.
      (gnus-demon-add-handler 'gnus-demon-scan-news 5 t)

      ;;  Kill the message buffer after sending an email instead of burying it.
      (setq message-kill-buffer-on-exit t)

      (setq mail-user-agent 'gnus-user-agent)
      (setq read-mail-command 'gnus-user-agent)))
#+END_SRC

* Helm

Use Helm everywhere.  I like the UI for Helm and the way that it allows for narrowing search results.  The downside is that it is the single largest hit to startup time in this config.  If I could get used to IDO after using Helm for so long I would because of the startup time issue.  I'm not sure if other people have this issue or not as I was unable to find any similar problems when doing a couple searches.  On an SSD the load time is fine but on my work machine which a HDD it is painful.

The configuration is pretty basic with the exception being mapping the tab key to helm-execute-persistent-action.  This was done so that it behaves in a similar way as bash.  Also I like to force Helm to always split the current window vertically.

#+BEGIN_SRC emacs-lisp :tangle yes :exports code
(use-package helm
  :ensure t
  :disabled t
  :diminish helm-mode
  :demand
  :bind (("C-M-s" . helm-occur)
         ("C-x C-f" . helm-find-files)
         ("M-x" . helm-M-x)
         ("C-x b" . ry/switch-buffer)
         ("C-x C-b" . helm-buffers-list)
         ("C-x r l" . helm-bookmarks)
         ("C-h f" . helm-apropos)
         ("C-h r" . helm-info-emacs)
         ("C-h C-l" . helm-locate-library)
         ("M-y" . helm-show-kill-ring)
         ("C-x C-b" . ry/switch-buffer)
         ("<f7>" . helm-bookmarks)
         ("<f8>" . bookmark-set))
  :bind (:map helm-map
              ("<tab>" . helm-execute-persistent-action)
              ("C-i" . helm-execute-persistent-action)
              ("C-z" . helm-select-action))
  :config
  (progn
    (require 'helm-config)  

    (helm-mode 1)

    (setq helm-quick-update                     t
          helm-split-window-in-side-p           t
          helm-buffers-fuzzy-matching           t
          helm-ff-search-library-in-sexp        t
          helm-scroll-amount                    8
          helm-ff-file-name-history-use-recentf t
          helm-skip-boring-buffers              t
          helm-skip-boring-files                t
          helm-buffer-max-length                30
          helm-autoresize-max-height            25
          helm-autoresize-min-height            25
          helm-boring-buffer-regexp-list '("\\` " "\\*helm" "\\*helm-mode" "\\*Echo Area" "\\*Minibuf" "\\*Calendar" "\\*magit-diff" "\\*magit-process")
          helm-mini-default-sources '(helm-source-buffers-list
                                      helm-source-recentf
                                      helm-source-bookmarks
                                      helm-source-buffer-not-found))
    
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ;;  Make helm always create a new window and always split the current window
    ;;  vertically.
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    (setq helm-display-function
          #'(lambda (buf)
            (split-window-vertically)
            (other-window 1)
            (switch-to-buffer buf)))))
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle yes :exports code
(use-package helm-swoop
  :ensure t
  :disabled t
      :after helm
      :bind (("M-i" . helm-swoop)
             ("M-I" . helm-swoop-back-to-last-point)
             ("C-c M-i" . heml-multi-swoop)
             ("C-x M-i" . heml-multi-swoop-all))
      :bind (:map isearch-mode-map
                  ("M-i" . helm-swoop-from-isearch))
      :bind (:map helm-swoop-map
                  ("M-i" . helm-multi-swoop-all-from-helm-swoop))
      :config
      (progn
        ;;  Split the current window.
        (setq helm-swoop-split-with-multiple-windows t)))
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle yes :exports code
(use-package helm-descbinds
  :ensure t
  :disabled t
  :after helm
  :config
  (helm-descbinds-mode))
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle yes :exports code
(use-package abbrev
  :diminish abbrev-mode)
#+END_SRC

Save the recent file history.  This is used by Helm.

#+BEGIN_SRC emacs-lisp :tangle yes :exports code
(use-package recentf
  :ensure t
  :commands (helm-mini)
  :init
  (progn
    (recentf-mode)
    (setq recentf-max-saved-items 25)
    (setq recentf-auto-cleanup 'never)
    (add-to-list 'recentf-exclude "COMMIT_EDITMSG\\'")))
#+END_SRC

* Ivy

#+BEGIN_SRC emacs-lisp :tangle yes :exports code
(use-package counsel
  :ensure t)
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle yes :exports code
(use-package ivy 
  :ensure t
  :diminish (ivy-mode . "")
  :bind (("C-M-s" . ivy-occur)
         ("C-x C-f" . counsel-find-file)
         ("M-x" . counsel-M-x)
         ("C-x b" . ivy-switch-buffer)
         ("C-x C-b" . ivy-switch-buffer)
         ("M-y" . counsel-yank-pop)
         ("C-s" . ry-counsel-grep-or-swiper))
  :bind (:map ivy-mode-map ("C-'" . ivy-avy))
  :config
  (ivy-mode 1)
  (counsel-mode 1)

  ;; add recentf-mode and bookmarks to ivy-switch-buffer.
  (setq ivy-use-virtual-buffers t)

  ;; number of result lines to display
  (setq ivy-height 15)

  ;; Remove ./ and ../ from ivy
  (setq ivy-extra-directories nil)

  ;; Color matching portions of candidates.
  (setq ivy-display-style 'fancy)
  ;;(setq ivy-display-style nil)
  
  ;; show candidate count
  (setq ivy-count-format "(%d/%d) ")

  ;; no regexp by default
  (setq ivy-initial-inputs-alist nil)

  ;; configure regexp engine.
  (setq ivy-re-builders-alist ;; allow input not in order
        '((t . ivy--regex-ignore-order)))

  (defun ry-counsel-grep-or-swiper ()
    "Save all buffers visiting files prior to calling counsel-grep-or-swiper due to
stability issues with the command."
    (interactive)
    ;; save all buffers that are visiting files.
    (cl-loop for b in (buffer-list)
             when (buffer-file-name b) do
             (with-current-buffer b
               (save-buffer)))
    (counsel-grep-or-swiper)))
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle yes :exports code
(use-package smex
  :ensure t)
#+END_SRC
  
#+BEGIN_SRC emacs-lisp :tangle yes :exports code
(use-package ivy-rich
  :ensure t
  :after ivy
  :config
  (ivy-set-display-transformer 'ivy-switch-buffer 'ivy-rich-switch-buffer-transformer))
#+END_SRC

* God Mode

I am not a huge fan of VIM but I can admit that the modal editing is better for my hands.  I spent all this time getting used to the Emacs keybindings so I am using god-mode instead of evil.

In addition to adding keybindings to help work with this mode I have added a hook to the post-command-hook to change the cursor.  The cursor will be a red box when god-mode is enabled and a regular pipe otherwise.  This done to help me remember which mode I am in.  At one time I had the mode-line change color but I didn't care for the colors on Solarized when I changed from Monokai.

A recent addition is mortal mode found here: [[https://github.com/chrisdone/god-mode/issues/77]].

#+BEGIN_SRC emacs-lisp :tangle yes :exports code
(use-package god-mode
  :ensure t
  :bind (("<escape>" . god-local-mode))
  :bind (:map god-local-mode-map
              ("z" . avy-goto-char-timer)
              ("i" . god-local-mode)
              ("v" . scroll-up-command)
              ("r" . ry/replace-character-at-point)
              ("DEL" . delete-backward-char)              
              ("C-n" . next-line)
              ("C-p" . previous-line)
              ("C-f" . forward-char)
              ("C-b" . backward-char)
              ("C-a" . prelude-move-beginning-of-line)
              ("C-e" . end-of-line)
              ("C-c C-x C-f" . ry/xml-format)
              ("C-c C-x C-l" . ry/xml-linearlize)
              ("C-c C-x C-w" . ry/xml-where)
              ("C-c C-d C-s" . ry/sql-send-dwim)
              ("C-c C-d C-e" . ry/sql-export-dwim)
              ("C-c C-d C-o" . ry/sql-open-database)
              ("C-c C-d C-O" . ry/sql-reopen-database)
              ("C-c C-d C-'" . ry/sql-wrap-in)
              ("C-c C-d C-r" . sql-send-region)
              ("C-c C-d C-d" . ry/sql-disconnect)
              ("C-c C-d C-q" . ry/sql-quit)
              ("C-x C-g" . magit-status)
              ("C-c C-g" . magit-status)
              ("C-c C-e C-p" . eclim-problems)
              ("C-c C-e C-c" . eclim-problems-correct)
              ("C-c C-e C-f" . eclim-java-format)
              ("C-c C-e C-o" . eclim-java-import-organize)
              ("C-c C-e C-g" . eclim-java-generate-getter-and-setter)
              ("C-c C-e C-r" . eclim-java-refactor-rename-symbol-at-point)
              ("C-c C-e C-i" . eclim-java-implement)
              ("C-c C-e C-." . eclim-java-find-declaration)
              ("C-c C-e C-t" . eclim-java-find-type)
              ("C-c C-e C-," . eclim-java-find-references)
              ("C-x C-1" . delete-other-windows)
              ("C-x C-2" . sacha/vsplit-last-buffer)
              ("C-x C-3" . sacha/hsplit-last-buffer)
              ("C-x C-0" . delete-window)
              ("C-x C-k" . kill-this-buffer)
              ("C-x C-S-k" . kill-other-buffers)
              ("C-x C-o" . other-window)
              ("C-x C-n" . narrow-or-widen-dwim)
              ("C-c C-r" . ry/copy-rectangle)
              ("C-C C-a" . org-agenda)
              ("C-x C-h" . mark-whole-buffer)
              ("C-x C-d" . dired))
  :init
  (progn
    (god-mode-all)

    ;;  Unbind the usual movement keys so that I am forced to use god mode.
    ;; (dolist (key '("\C-n" "\C-p" "\C-b" "\C-f" "\C-a" "\C-e"))
    ;;   (global-unset-key key))
    
    (setq god-exempt-major-modes nil)
    (add-to-list 'god-exempt-major-modes 'dired-mode)
    (add-to-list 'god-exempt-major-modes 'org)
    (add-to-list 'god-exempt-major-modes 'eshell-mode)
    (add-to-list 'god-exempt-major-modes 'org-agenda-mode)
    (add-to-list 'god-exempt-major-modes 'magit-popup-mode)
    (add-to-list 'god-exempt-major-modes 'magit-popup-help-mode)
    (add-to-list 'god-exempt-major-modes 'magit-status-mode)
    (add-to-list 'god-exempt-major-modes 'magit-mode)
    (add-to-list 'god-exempt-major-modes 'special-mode)

    ;;  Change the color of the cursor to RED if god-mode is enabled.  If the file is
    ;;  read-only than change the cursor to a purple box and disallow changing from
    ;;  god-mode.
    (add-hook 'post-command-hook
              #'(lambda ()
                  (cond (buffer-read-only
                         (set-cursor-color "#7b68ee"))
                         ;; (setq cursor-type 'box))
                        ((bound-and-true-p god-local-mode)
                         (set-cursor-color "#b22222")
                         ;; (setq cursor-type 'box)
                         (set-face-attribute 'mode-line nil
                                             :foreground "#ffffff" :background "#b22222" ;;"#ff1493"
                                             :inverse-video nil
                                             :box '(:line-width 1 :color "#b22222" :style nil)))
                        (t
                         (set-cursor-color "#839496")
                         ;; (setq cursor-type 'bar)
                         (set-face-attribute 'mode-line nil
                                             :foreground "#ffffff" :background "#006400"
                                             :inverse-video nil
                                             :box '(:line-width 1 :color "#006400" :style nil))))))))
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle yes :exports code
(use-package god-mode-isearch
  :demand
  :after god-mode
  :bind (:map isearch-mode-map
              ("<escape>" . god-mode-isearch-activate))
  :bind (:map god-mode-isearch-map
             ("<escape>" . god-mode-isearch-disable)))
#+END_SRC

* Org-Mode

What is there to say.  Doesn't everyone who uses Emacs also use org-mode?  My org-mode configuration is contained in another file but will eventually be merged into this one and documented.  Org-plus-contib was added to the config and then had to be removed.  It caused issues with continuous clocking, locating headlines by their ID property would not work when it was enabled.  This is only an issue when trying to send HTML emails using org-mime.

Ox-twbs was added for exporting documents using the Twitter bootstrap.  Not sure if I like this more or less than bigblow.

#+BEGIN_SRC emacs-lisp :tangle yes :exports code
(use-package org
  :ensure t ;org-plus-contrib
  :mode 
  (("\\.org\\'" . org-mode))
  :bind* (("C-M-r" . org-capture)
          ("C-c r" . org-capture)
          ("C-c a" . org-agenda)
          ("<f10>" . ry/org-capture-todo)
          ("<f9> <f9>" . bh/show-org-agenda)
          ("<f9> r" . org-capture)
          ("<f9> i" . org-clock-in)
          ("<f9> o" . org-clock-out)
          ("<f9> I" . bh/punch-in)
          ("<f9> O" . bh/punch-out)
          ("<f9> g" . org-clock-goto)
          ("<f9> n" . ry/org-start-note))
  :bind (:map org-agenda-mode-map
              ("x" . ivy-switch-buffer)
              ("q" . nil)
              ("b" . nil)
              ("n" . org-agenda-next-item)
              ("p" . org-agenda-previous-item))
  :config
  (progn    
    (use-package org-bullets
      :ensure t
      :config
      (progn
        (add-hook 'org-mode-hook #'(lambda () (org-bullets-mode 1)))
        (add-hook 'org-mode-hook #'(lambda () (visual-line-mode)))))

    (use-package org-table-sticky-header
      :ensure t
      :diminish 'org-table-sticky-header
      :config
      (add-hook 'org-mode-hook 'org-table-sticky-header-mode))

    (use-package org-sticky-header
      :ensure t
      :config
      (add-hook 'org-mode-hook 'org-sticky-header-mode))

    (use-package ox-twbs
      :commands (org-twbs-export-to-html org-twbs-export-as-html)
      :ensure t)

    ;;(add-to-list 'auto-mode-alist '("\\.\\(org\\|org_archive\\)$" . org-mode))
    
    (require 'org-habit)    

    (when (at-work-p)
      (setq org-babel-java-compiler "C:/IBM/SDP/jdk/bin/javac.exe")
      (setq org-babel-java-command "C:/IBM/SDP/jdk/bin/java.exe"))

    ;;  Make Windows use the correct application for a number
    ;;  of Office file extensions.
    (mapc #'(lambda (v)
              (push v org-file-apps)) '(("\\.doc\\'" . default) 
                                        ("\\.docx\\'" . default)
                                        ("\\.xlsx\\'" . default)
                                        ("\\.xls\\'" . default) 
                                        ("\\.xlsm\\'" . default)))
    
    ;;  Use yasnippets for templates instead.
    (setq org-structure-template-alist nil)

    ;;  Clock continuously.
    (setq org-clock-continuously t)

    (setq org-use-speed-commands t)
    (setq org-speed-commands-user (quote (("0" . ignore)
                                          ("1" . ignore)
                                          ("2" . ignore)
                                          ("3" . ignore)
                                          ("4" . ignore)
                                          ("5" . ignore)
                                          ("6" . ignore)
                                          ("7" . ignore)
                                          ("8" . ignore)
                                          ("9" . ignore)

                                          ("a" . ignore)
                                          ("d" . ignore)
                                          ("h" . ignore)
                                          ("i" . ignore)
                                          ("k" . ignore)
                                          ("l" . ignore)
                                          ("m" . ignore)
                                          ("q" . ignore)
                                          ("r" . ignore)
                                          ("s" . org-save-all-org-buffers)
                                          ("w" . org-refile)
                                          ("x" . ignore)
                                          ("y" . ignore)
                                          ("z" . org-add-note)

                                          ("A" . ignore)
                                          ("B" . ignore)
                                          ("E" . ignore)
                                          ("F" . ignore)
                                          ("G" . ignore)
                                          ("H" . ignore)
                                          ("J" . org-clock-goto)
                                          ("K" . ignore)
                                          ("L" . ignore)
                                          ("M" . ignore)
                                          ("N" . ignore)
                                          ("P" . ignore)
                                          ("Q" . ignore)                                      
                                          ("S" . ignore)
                                          ("T" . ignore)
                                          ("U" . ignore)
                                          ("V" . ignore)
                                          ("W" . ignore)
                                          ("X" . ignore)
                                          ("Y" . ignore)
                                          ("Z" . ignore))))

    ;;  Set the org ellipsis to something nicer.
    (setq org-ellipsis " ")

    ;;  Set this so that the agenda doesn't show scheduled: next to items in the calendar if they are scheduled
    ;;  it seems silly to show scheduled if we know it is scheduled.
    (setq org-agenda-scheduled-leaders '("" "Sched.%2dx: "))

    (defun ry/org-start-note ()
      "Small function to insert an inactive timestamp and a hyphen to start a note."
      (interactive)      
      (org-insert-time-stamp (current-time) t t)
      (insert " - "))

    (defun ry/org-set-ritm (ritm-number)
      "Add the RITM property with the RITM number
and also set the RITM tag."
      (interactive "sRITM number: ")
      (let ((cur (org-entry-get nil "RITM")))
        (cond ((= (length ritm-number) 0)
               (org-toggle-tag "RITM" 'off)
               (org-delete-property "RITM"))
              (cur
               (org-set-property "RITM" (concat cur "," ritm-number)))
              (t
               (org-set-property "RITM" ritm-number)
               (org-toggle-tag "RITM" 'on)))))

    (defun ry/org-set-migration (environment migration-number)
      "Add the MIGRATION property with the migration
number and also set the MIGRATED tag."
      (interactive (list
                    (ivy-read "Environment: " '("PROD" "UTM") :predicate nil :require-match t)
                    (read-string "Migration number: ")))
      (if (s-equals-p environment "UTM")
          (progn 
            (org-set-property "UTM_MIGRATION" migration-number)
            (org-toggle-tag "UTM" 'on))
        (org-set-property "PROD_MIGRATION" migration-number)
            (org-toggle-tag "PROD" 'on)))
    
    (defun ry/org-agenda-after-show-hook ()
      "Show the subtree when viewing it from the agenda."
      (org-show-subtree)
      (org-narrow-to-subtree))

      (defun ry/org-capture-todo ()
        "Helper function to capture a TODO using the right template."
        (interactive)
        (org-capture nil "t"))

    (setq org-agenda-after-show-hook 'ry/org-agenda-after-show-hook)

    (setq org-clock-goto-hook 'ry/org-agenda-after-show-hook)

    (setq org-agenda-span 2)
    (setq org-agenda-timegrid-use-ampm t)
    (setq org-agenda-time-grid
          '((daily today require-timed)
            "----------------"
            (800 1000 1200 1400 1600 1800)))
    (setq org-columns-default-format "%50ITEM %12SCHEDULED %TODO %3PRIORITY %Effort{:} %TAGS")

    ;;  Show recently logged tasks in the time grid.
    (setq org-agenda-show-log t)

    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ;;  Only load the work related outlook capture handler if I am at work.
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    (when (at-work-p)
      (load "~/.emacs.d/org-outlook-capture.el"))

    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ;;  ORG-MODE hooks.
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ;; Enable abbrev-mode
    (add-hook 'org-mode-hook #'(lambda () (abbrev-mode 1)))

    ;; flyspell mode for spell checking everywhere
    (add-hook 'org-mode-hook 'turn-on-flyspell 'append)

    ;; Always hilight the current agenda line
    (add-hook 'org-agenda-mode-hook
              '(lambda () 
                 (hl-line-mode 1)
                 (visual-line-mode 0)
                 (toggle-truncate-lines 1))
              'append)

    (org-clock-persistence-insinuate)

    ;; Show lot of clocking history so it's easy to pick items off the C-F11 list
    (setq org-clock-history-length 23)

    ;; Resume clocking task on clock-in if the clock is open
    (setq org-clock-in-resume t)

    ;; Change tasks to NEXT when clocking in
    (setq org-clock-in-switch-to-state 'bh/clock-in-to-next)

    ;; Separate drawers for clocking and logs
    (setq org-drawers (quote ("PROPERTIES" "LOGBOOK")))

    ;; Save clock data and state changes and notes in the LOGBOOK drawer
    (setq org-clock-into-drawer t)

    ;; Sometimes I change tasks I'm clocking quickly - this removes clocked tasks with 0:00 duration
    (setq org-clock-out-remove-zero-time-clocks t)

    ;; Clock out when moving task to a done state
    (setq org-clock-out-when-done t)

    ;; Save the running clock and all clock history when exiting Emacs, load it on startup
    (setq org-clock-persist t)

    ;; Do not prompt to resume an active clock
    (setq org-clock-persist-query-resume nil)

    ;; Enable auto clock resolution for finding open clocks
    (setq org-clock-auto-clock-resolution (quote when-no-clock-is-running))

    ;; Include current clocking task in clock reports
    (setq org-clock-report-include-clocking-task t)

    (setq bh/keep-clock-running nil)

    ;; Check for clocking longer than four hours.
    (setq org-agenda-clock-consistency-checks
          '(:max-duration "4:00"
                          :min-duration 0
                          :max-gap 0
                          :gap-ok-around ("4:00")))

    (defun bh/clock-in-to-next (kw)
      "Switch a task from TODO to NEXT when clocking in.
Skips capture tasks, projects, and subprojects.
Switch projects and subprojects from NEXT back to TODO"
      (when (not (and (boundp 'org-capture-mode) org-capture-mode))
        (cond
         ((and (member (org-get-todo-state) (list "TODO"))
               (bh/is-task-p))
          "NEXT")
         ((and (member (org-get-todo-state) (list "NEXT"))
               (bh/is-project-p))
          "TODO"))))

    (defun bh/find-project-task ()
      "Move point to the parent (project) task if any"
      (save-restriction
        (widen)
        (let ((parent-task (save-excursion (org-back-to-heading 'invisible-ok) (point))))
          (while (org-up-heading-safe)
            (when (member (nth 2 (org-heading-components)) org-todo-keywords-1)
              (setq parent-task (point))))
          (goto-char parent-task)
          parent-task)))

    (defun bh/punch-in (arg)
      "Start continuous clocking and set the default task to the
 selected task.  If no task is selected set the Organization task
 as the default task."
      (interactive "p")
      (setq bh/keep-clock-running t)
      (if (equal major-mode 'org-agenda-mode)
          
          ;; We're in the agenda
          
          (let* ((marker (org-get-at-bol 'org-hd-marker))
                 (tags (org-with-point-at marker (org-get-tags-at))))
            (if (and (eq arg 4) tags)
                (org-agenda-clock-in '(16))
              (bh/clock-in-organization-task-as-default)))
        
        ;; We are not in the agenda
        
        (save-restriction
          (widen)
                                        ; Find the tags on the current task
          (if (and (equal major-mode 'org-mode) (not (org-before-first-heading-p)) (eq arg 4))
              (org-clock-in '(16))
            (bh/clock-in-organization-task-as-default)))))

;;    (defun bh/punch-in (arg)
;;      "Start continuous clocking and set the Organization task
;;    as the default task."
;;      (interactive "p")
;;      (setq bh/keep-clock-running t)
;;      (bh/clock-in-organization-task-as-default))

    (defun bh/punch-out ()
      (interactive)
      (setq bh/keep-clock-running nil)
      (when (org-clock-is-active)
        (org-clock-out))
      (org-agenda-remove-restriction-lock))

    (defun bh/clock-in-default-task ()
      (save-excursion
        (org-with-point-at org-clock-default-task
          (org-clock-in))))

    (defun bh/clock-in-parent-task ()
      "Move point to the parent (project) task if any and clock in"
      (let ((parent-task))
        (save-excursion
          (save-restriction
            (widen)
            (while (and (not parent-task) (org-up-heading-safe))
              (when (member (nth 2 (org-heading-components)) org-todo-keywords-1)
                (setq parent-task (point))))
            (if parent-task
                (org-with-point-at parent-task
                  (org-clock-in))
              (when bh/keep-clock-running
                (bh/clock-in-default-task)))))))

    (defvar bh/organization-task-id "ae2a4626-416d-4244-8a2a-e15bca7b971d")
    (defvar ry/email-task-id "b86a72cd-99f1-435f-969c-dacd4a54b6b7")
    (defvar ry/lats-task-id "81a916f6-59b6-4b5d-a381-211ec3388b14")

    (defun bh/clock-in-organization-task-as-default ()
      (interactive)
      (org-with-point-at (org-id-find bh/organization-task-id 'marker)
        (org-clock-in '(16))))

    (defun bh/clock-out-maybe ()
      (when (and bh/keep-clock-running
                 (not org-clock-clocking-in)
                 (marker-buffer org-clock-default-task)
                 (not org-clock-resolving-clocks-due-to-idleness))
        (bh/clock-in-parent-task)))

    (defun ry/clock-in-email ()
      "Clock in the email task."
      (interactive)
      (org-with-point-at (org-id-find ry/email-task-id 'marker)
        (org-clock-in '(16))))

    (defun ry/clock-in-lats ()
      "Clock in the email task."
      (interactive)
      (org-with-point-at (org-id-find ry/lats-task-id 'marker)
        (org-clock-in '(16))))

    (add-hook 'org-clock-out-hook 'bh/clock-out-maybe 'append)

    (defun bh/show-org-agenda ()
      (interactive)
      (if org-agenda-sticky
          (switch-to-buffer "*Org Agenda( )*")
        (switch-to-buffer "*Org Agenda*"))
      (delete-other-windows))

    ;;  Set files that should be used as part of the adgenda.
    (setq org-agenda-files (quote ("~/emacs/Org/refile.org"                             
                                   "~/emacs/Org/das.org")))

    (setq org-todo-keywords
          (quote ((sequence "TODO(t)" "NEXT(n)" "MIGRATED(m)" "MEETING(g)" "EMAIL(e)" "|" "DONE(d)" "RESCHEDULED(r)")
                  (sequence "WAITING(w@/!)" "HOLD(h@/!)" "|" "CANCELLED(c@/!)"))))

    (setq org-todo-keyword-faces
          (quote (("TODO" :foreground "red" :weight bold)
                  ("NEXT" :foreground "light slate blue" :weight bold)
                  ("DONE" :foreground "forest green" :weight bold)
                  ("WAITING" :foreground "orange" :weight bold)
                  ("HOLD" :foreground "magenta" :weight bold)
                  ("CANCELLED" :foreground "forest green" :weight bold)
                  ("MIGRATED" :foreground "sea green" :weight bold)
                  ("MEETING" :foreground "lemon chiffon" :weight bold)
                  ("EMAIL" :foreground "saddle brown" :weight bold))))

    (setq org-use-fast-todo-selection t)

    (setq org-treat-S-cursor-todo-selection-as-state-change nil)

    (setq org-todo-state-tags-triggers
          (quote (("CANCELLED" ("CANCELLED" . t))
                  ("WAITING" ("WAITING" . t))
                  ("HOLD" ("WAITING" . t) ("HOLD" . t))
                  ("DONE" ("WAITING") ("HOLD"))
                  ("TODO" ("WAITING") ("CANCELLED") ("HOLD"))
                  ("MEETING" ("CANCELLED") ("RESCHEDULED") ("DONE"))
                  ("NEXT" ("WAITING") ("CANCELLED") ("HOLD"))
                  ("DONE" ("WAITING") ("CANCELLED") ("HOLD"))
                  ("MIGRATED" ("MIGRATED" . t) ("WAITING") ("CANCELLED") ("HOLD") ("DONE")))))

    (setq org-directory "~/emacs/Org")
    (setq org-default-notes-file "~/emacs/Org/refile.org")

    ;; Capture templates for: TODO tasks, Notes, appointments, phone calls, and org-protocol
    (setq org-capture-templates
          (quote (("t" "todo" entry (file+headline "~/emacs/Org/refile.org" "Refile")
                   "* TODO %?\n  %U\n" :clock-in t :clock-resume t)
                  ("r" "respond" entry (file+headline "~/emacs/Org/refile.org" "Refile")
                   "* NEXT Respond to %:from on %:subject\nSCHEDULED: %t\n%U\n%a\n" :clock-in t :clock-resume t :immediate-finish t)
                  ("n" "note" entry (file+headline "~/emacs/Org/refile.org" "Refile")
                   "* %?\n  %U\n" :clock-in t :clock-resume t)
                  ("w" "org-protocol" entry (file+headline "~/emacs/Org/refile.org" "Refile")
                   "* TODO Review %c\n%U\n" :immediate-finish t)
                  ("h" "Habit" entry (file+headline "~/emacs/Org/refile.org" "Refile")
                   "* NEXT %?\n%U\n%a\nSCHEDULED: %(format-time-string \"<%Y-%m-%d %a .+1d/3d>\")\n:PROPERTIES:\n:STYLE: habit\n:REPEAT_TO_STATE: NEXT\n:END:\n")
                  ("m" "Meeting" entry (file+headline "~/emacs/Org/refile.org" "Refile")
                   "* TODO %?\nSCHEDULED: %t\n%U\n- Room :: \n- Time :: \n- Attendees ::\n  - [ ] \n- Background :: \n  -\n- Meeting notes :: \n  -"))))

    ;;  Remove this on 09/04/2015 as it was causing problems with a new version of org-mode.
    ;;(add-hook 'org-clock-out-hook 'bh/remove-empty-drawer-on-clock-out 'append)

                                        ; Targets include this file and any file contributing to the agenda - up to 9 levels deep
    (setq org-refile-targets (quote ((nil :maxlevel . 9)
                                     (org-agenda-files :maxlevel . 9))))

                                        ; Use full outline paths for refile targets - we file directly with IDO
    (setq org-refile-use-outline-path t)

                                        ; Targets complete directly with IDO
    (setq org-outline-path-complete-in-steps nil)

                                        ; Allow refile to create parent tasks with confirmation
    (setq org-refile-allow-creating-parent-nodes (quote confirm))

    (setq org-refile-target-verify-function 'bh/verify-refile-target)

    ;; Dim blocked tasks 
    (setq org-enforce-todo-dependencies t)
    (setq org-agenda-dim-blocked-tasks nil) 

    ;; Compact the block agenda view (disabled) 
    (setq org-agenda-compact-blocks nil) 

    ;; Custom agenda command definitions
    (setq org-agenda-custom-commands
          (quote (("N" "Notes" tags "NOTE"
                   ((org-agenda-overriding-header "Notes")
                    (org-tags-match-list-sublevels t)))
                  ("h" "Habits" tags-todo "STYLE=\"habit\""
                   ((org-agenda-overriding-header "Habits")
                    (org-agenda-sorting-strategy
                     '(todo-state-down effort-up category-keep))))
                  (" " "Agenda"
                   ((agenda "" ((org-agenda-overriding-header "Todays Schedule:")
                                (org-agenda-span 1)
                                (org-agenda-start-on-weekday nil)
                                (org-agenda-start-day "+0d")
                                (org-agenda-todo-ignore-deadlines nil)))                    
                    (agenda "" ((org-agenda-overriding-header "Week At A Glance:")
                                (org-agenda-span
                                 (cond ((s-equals? (format-time-string "%a") "Mon") 4)
                                       ((s-equals? (format-time-string "%a") "Tue") 3)
                                       ((s-equals? (format-time-string "%a") "Wed") 2)
                                       ((s-equals? (format-time-string "%a") "Thu") 1)
                                       (t 0)))
                                (org-agenda-start-day "+1d")
                                (org-agenda-prefix-format '((agenda . "  %-12:c%?-12t %s")))))
                    (tags-todo "REFILE"
                               ((org-agenda-overriding-header "Tasks to Refile")
                                (org-tags-match-list-sublevels nil)))                    
                    (tags-todo "-HOLD-CANCELLED/!"
                               ((org-agenda-overriding-header "Projects")
                                (org-agenda-skip-function 'bh/skip-non-projects)
                                (org-agenda-sorting-strategy
                                 '(category-keep))))
                    (tags-todo "-HOLD-CANCELLED-JOSH-MIGRATED/!"
                               ((org-agenda-overriding-header "Stuck Projects")
                                (org-agenda-skip-function 'bh/skip-non-stuck-projects)))
                    (tags-todo "-WAITING-CANCELLED-KRANTHI-RITA-TIFFANY-NICK-JOSH-REFILE-CLOCK/!NEXT"
                               ((org-agenda-overriding-header "Next Tasks")
                                (org-agenda-skip-function 'bh/skip-projects-and-habits-and-single-tasks)
                                (org-agenda-todo-ignore-scheduled t)
                                (org-agenda-todo-ignore-deadlines t)
                                (org-agenda-todo-ignore-with-date t)
                                (org-tags-match-list-sublevels t)
                                (org-agenda-sorting-strategy
                                 '(todo-state-down effort-up category-keep))))
                    (tags-todo "-WAITING-REFILE-CANCELLED-KRANTHI-RITA-TIFFANY-NICK-JOSH-WISHLIST/!-HOLD-WAITING-NEXT-MIGRATED-KRANTHI-RITA-TIFFANY-NICK-JOSH-WISHLIST"
                               ((org-agenda-overriding-header "Tasks")
                                (org-agenda-skip-function 'bh/skip-project-tasks-maybe)
                                (org-agenda-todo-ignore-scheduled t)
                                (org-agenda-todo-ignore-deadlines t)
                                (org-agenda-todo-ignore-with-date t)
                                (org-agenda-sorting-strategy
                                 '(category-keep))))
                    (tags-todo "WISHLIST/-MIGRATED"
                               ((org-agenda-overriding-header "Wishlist")
                                (org-agenda-skip-function 'ry/skip-non-projects-and-non-singletons)
                                (org-agenda-todo-ignore-scheduled t)
                                (org-agenda-sorting-strategy
                                 '(category-keep))))
                    (tags-todo "TIFFANY/-MIGRATED"
                               ((org-agenda-overriding-header "Tiffany H.")
                                (org-agenda-skip-function 'ry/skip-non-projects-and-non-singletons)
                                (org-agenda-todo-ignore-scheduled t)
                                (org-agenda-sorting-strategy
                                 '(category-keep))))
                    (tags-todo "RITA/-MIGRATED"
                               ((org-agenda-overriding-header "Rita J.")
                                (org-agenda-skip-function 'ry/skip-non-projects-and-non-singletons)
                                (org-agenda-todo-ignore-scheduled t)
                                (org-agenda-sorting-strategy
                                 '(category-keep))))
                    (tags-todo "JOSH/-MIGRATED"
                               ((org-agenda-overriding-header "Josh P.")
                                (org-agenda-skip-function 'ry/skip-non-projects-and-non-singletons)
                                (org-agenda-todo-ignore-scheduled t)
                                (org-agenda-sorting-strategy
                                 '(category-keep))))
                    (tags-todo "KRANTHI/-MIGRATED"
                               ((org-agenda-overriding-header "Kranthi G.")
                                (org-agenda-skip-function 'ry/skip-non-projects-and-non-singletons)
                                (org-agenda-todo-ignore-scheduled t)
                                (org-agenda-sorting-strategy
                                 '(category-keep))))                                                  
                    (tags-todo "NICK/-MIGRATED"
                               ((org-agenda-overriding-header "Nick H.")
                                (org-agenda-skip-function 'ry/skip-non-projects-and-non-singletons)
                                (org-agenda-todo-ignore-scheduled t)
                                (org-agenda-sorting-strategy
                                 '(category-keep))))                                
                    (todo "MIGRATED"
                          ((org-agenda-overriding-header "Migrated")
                           (org-agenda-skip-function 'ry/skip-non-projects-and-non-singletons)
                           (org-agenda-sorting-strategy
                            '(category-keep))))
                    (tags-todo "-CANCELLED+WAITING/!"
                               ((org-agenda-overriding-header "Waiting and Postponed Tasks")
                                (org-agenda-skip-function 'bh/skip-stuck-projects)
                                (org-tags-match-list-sublevels nil)
                                (org-agenda-todo-ignore-scheduled 'future)
                                (org-agenda-todo-ignore-deadlines 'future)))
                    (tags "-REFILE/"
                          ((org-agenda-overriding-header "Tasks to Archive")
                           (org-agenda-skip-function 'bh/skip-non-archivable-tasks)
                           (org-tags-match-list-sublevels nil)))
                    nil))
                  ("r" "Tasks to Refile" tags "REFILE"
                   ((org-agenda-overriding-header "Tasks to Refile")
                    (org-tags-match-list-sublevels t)))
                  ("#" "Stuck Projects" tags-todo "-CANCELLED/!"
                   ((org-agenda-overriding-header "Stuck Projects")
                    (org-agenda-skip-function 'bh/skip-non-stuck-projects)))
                  ("n" "Next Tasks" tags-todo "-WAITING-CANCELLED/!NEXT"
                   ((org-agenda-overriding-header "Next Tasks")
                    (org-agenda-skip-function 'bh/skip-projects-and-habits-and-single-tasks)
                    (org-agenda-todo-ignore-scheduled t)
                    (org-agenda-todo-ignore-deadlines t)
                    (org-agenda-todo-ignore-with-date t)
                    (org-tags-match-list-sublevels t)
                    (org-agenda-sorting-strategy
                     '(todo-state-down effort-up category-keep))))
                  ("R" "Tasks" tags-todo "-REFILE-CANCELLED/!-HOLD-WAITING"
                   ((org-agenda-overriding-header "Tasks")
                    (org-agenda-skip-function 'bh/skip-project-tasks-maybe)
                    (org-agenda-sorting-strategy
                     '(category-keep))))
                  ("p" "Projects" tags-todo "-HOLD-CANCELLED/!"
                   ((org-agenda-overriding-header "Projects")
                    (org-agenda-skip-function 'bh/skip-non-projects)
                    (org-agenda-sorting-strategy
                     '(category-keep))))
                  ("w" "Waiting Tasks" tags-todo "-CANCELLED+WAITING/!"
                   ((org-agenda-overriding-header "Waiting and Postponed tasks"))
                   (org-tags-match-list-sublevels nil))
                  ("A" "Tasks to Archive" tags "-REFILE/"
                   ((org-agenda-overriding-header "Tasks to Archive")
                    (org-agenda-skip-function 'bh/skip-non-archivable-tasks)
                    (org-tags-match-list-sublevels nil))))))

    ;; Sometimes I change tasks I'm clocking quickly - this removes clocked tasks with 0:00 duration
    (setq org-clock-out-remove-zero-time-clocks t)

    (setq org-time-stamp-rounding-minutes (quote (1 1)))

    ;; Agenda clock report parameters
    (setq org-agenda-clockreport-parameter-plist
          (quote (:link t :maxlevel 5 :fileskip0 t :compact t :narrow 80)))

    ;; Agenda log mode items to display (closed and state changes by default)
    (setq org-agenda-log-mode-items (quote (closed state)))

                                        ; Allow setting single tags without the menu
    (setq org-fast-tag-selection-single-key (quote expert))

                                        ; For tag searches ignore tasks with scheduled and deadline dates
    (setq org-agenda-tags-todo-honor-ignore-options t)

    (setq org-agenda-span 'day)

    (setq org-stuck-projects (quote ("" nil nil "")))

    (setq org-archive-mark-done nil)
    (setq org-archive-location "%s_archive::* Archived Tasks")

    (setq org-ditaa-jar-path "~/emacs/Java/ditaa0_9.jar")
    (setq org-plantuml-jar-path "~/emacs/Java/plantuml.jar")

                                        ; Make babel results blocks lowercase
    (setq org-babel-results-keyword "results")

    (org-babel-do-load-languages
     (quote org-babel-load-languages)
     (quote ((emacs-lisp . t)
             (dot . t)
             (ditaa . t)
             (gnuplot . t)
             (clojure . t)
             (sh . t)
             (java . t)
             (org . t)
             (plantuml . t))))

                                        ; Do not prompt to confirm evaluation
                                        ; This may be dangerous - make sure you understand the consequences
                                        ; of setting this -- see the docstring for details
    (setq org-confirm-babel-evaluate nil)

                                        ; Use fundamental mode when editing plantuml blocks with C-c '
    (add-to-list 'org-src-lang-modes (quote ("plantuml" . fundamental)))

    ;; Don't enable this because it breaks access to emacs from my Android phone
    (setq org-startup-with-inline-images nil)

                                        ; Inline images in HTML instead of producting links to the image
    (setq org-html-inline-images t)

                                        ; Use org.css from the norang website for export document stylesheets
    (setq org-html-style-extra "<link rel=\"stylesheet\" href=\"style.css\" type=\"text/css\" />")
    (setq org-html-style-include-default nil)

                                        ; Do not generate internal css formatting for HTML exports
    (setq org-htmlize-output-type (quote css))

                                        ; Export with LaTeX fragments
    (setq org-with-LaTeX-fragments t)

                                        ; Increase default number of headings to export
    (setq org-headline-levels 6)

    (setq org-allow-BIND t)

                                        ; Rebuild the reminders everytime the agenda is displayed
    (add-hook 'org-finalize-agenda-hook 'bh/org-agenda-to-appt 'append)

    (setq org-show-entry-below (quote ((default))))

    ;; Keep tasks with dates on the global todo lists
    (setq org-agenda-todo-ignore-with-date nil)

    ;; Keep tasks with deadlines on the global todo lists
    (setq org-agenda-todo-ignore-deadlines nil)

    ;; Keep tasks with scheduled dates on the global todo lists
    (setq org-agenda-todo-ignore-scheduled nil)

    ;; Keep tasks with timestamps on the global todo lists
    (setq org-agenda-todo-ignore-timestamp nil)

    ;; Remove completed deadline tasks from the agenda view
    (setq org-agenda-skip-deadline-if-done t)

    ;; Remove completed scheduled tasks from the agenda view
    (setq org-agenda-skip-scheduled-if-done t)

    ;; Remove completed items from search results
    (setq org-agenda-skip-timestamp-if-done t)

    ;; Include agenda archive files when searching for things
    (setq org-agenda-text-search-extra-files (quote (agenda-archives)))

    ;; Show all future entries for repeating tasks
    (setq org-agenda-repeating-timestamp-show-all t)

    ;; Show all agenda dates - even if they are empty
    (setq org-agenda-show-all-dates t)

    ;; Sorting order for tasks on the agenda
    (setq org-agenda-sorting-strategy
          (quote ((agenda habit-down time-up user-defined-up priority-down effort-up category-keep)
                  (todo category-up priority-down effort-up)
                  (tags category-up priority-down effort-up)
                  (search category-up))))

    ;; Start the weekly agenda on Monday
    (setq org-agenda-start-on-weekday 1)

    ;; Enable display of the time grid so we can see the marker for the current time
    (setq org-agenda-time-grid (quote ((daily today remove-match)
                                       #("----------------" 0 16 (org-heading t))
                                       (0900 1100 1300 1500 1700))))

    ;; Display tags farther right
    (setq org-agenda-tags-column -130)
    ;; (setq org-agenda-tags-column -80)

    (setq org-agenda-cmp-user-defined 'bh/agenda-sort)

    (setq org-enforce-todo-dependencies t)

    (setq org-hide-leading-stars nil)

    (setq org-cycle-separator-lines 0)

    (setq org-blank-before-new-entry (quote ((heading)
                                             (plain-list-item . auto))))

    (setq org-insert-heading-respect-content nil)

    (setq org-reverse-note-order nil)

    (setq org-show-following-heading t)
    (setq org-show-hierarchy-above t)
    (setq org-show-siblings (quote ((default))))

    (setq org-special-ctrl-a/e t)
    (setq org-special-ctrl-k t)
    (setq org-yank-adjusted-subtrees t)

    (setq org-id-method (quote uuidgen))

    (setq org-deadline-warning-days 30)

    (setq org-table-export-default-format "orgtbl-to-csv")

                                        ; Use the current window for C-c ' source editing
    (setq org-src-window-setup 'current-window)

    (setq org-log-done (quote time))
    (setq org-log-into-drawer t)
    (setq org-log-state-notes-insert-after-drawers nil)

                                        ; Enable habit tracking (and a bunch of other modules)
    (setq org-modules (quote (org-id
                              org-info
                              org-habit
                              org-inlinetask
                              org-protocol)))

                                        ; position the habit graph on the agenda to the right of the default
    (setq org-habit-graph-column 80)

    (run-at-time "06:00" 86400 '(lambda () (setq org-habit-show-habits t)))

    (global-auto-revert-mode t)

    (setq require-final-newline t)

    (add-hook 'org-insert-heading-hook 'bh/insert-heading-inactive-timestamp 'append)

    (setq org-with-timestamps nil)

    (setq org-return-follows-link t)

    (setq org-remove-highlights-with-change nil)

    (setq org-read-date-prefer-future 'time)

    (setq org-list-demote-modify-bullet (quote (("+" . "-")
                                                ("*" . "-")
                                                ("1." . "-")
                                                ("1)" . "-"))))

    (setq org-tags-match-list-sublevels t)

    (setq org-agenda-persistent-filter t)

    (setq org-agenda-skip-additional-timestamps-same-entry t)

    (setq org-table-use-standard-references (quote from))

    (setq org-file-apps (quote ((auto-mode . emacs)
                                ("\\.mm\\'" . system)
                                ("\\.x?html?\\'" . system)
                                ("\\.pdf\\'" . system))))

    ;; Overwrite the current window with the agenda
    (setq org-agenda-window-setup 'current-window)

    (setq org-clone-delete-id t)

    (setq org-cycle-include-plain-lists t)

    (setq org-src-fontify-natively t)
    (setq org-fontify-whole-heading-line t)

    (add-hook 'org-after-todo-state-change-hook 'bh/mark-next-parent-tasks-todo 'append)

    (setq org-startup-folded t)

    (setq org-list-allow-alphabetical t)

    (setq org-enable-priority-commands t)
    (setq org-default-priority ?E)
    (setq org-lowest-priority ?E)

    (setq org-coding-system 'utf-8)

    (setq org-src-preserve-indentation nil)
    (setq org-edit-src-content-indentation 0)

    (setq org-catch-invisible-edits 'error)

    (prefer-coding-system 'utf-8)
    (set-charset-priority 'unicode)
    (setq default-process-coding-system '(utf-8-unix . utf-8-unix))

    (setq org-time-clocksum-format
          '(:hours "%d" :require-hours t :minutes ":%02d" :require-minutes t))

    (setq org-emphasis-alist (quote (("*" bold "<b>" "</b>")
                                     ("/" italic "<i>" "</i>")
                                     ("_" underline "<span style=\"text-decoration:underline;\">" "</span>")
                                     ("=" org-code "<code>" "</code>" verbatim)
                                     ("~" org-verbatim "<code>" "</code>" verbatim))))

    (setq org-use-sub-superscripts nil)

    (setq org-odd-levels-only nil)

    (run-at-time "00:59" 3600 'org-save-all-org-buffers)

    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ;;  Functions related to ORG-MODE.
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    (defun bh/org-todo (arg)
      (interactive "p")
      (if (equal arg 4)
          (save-restriction
            (bh/narrow-to-org-subtree)
            (org-show-todo-tree nil))
        (bh/narrow-to-org-subtree)
        (org-show-todo-tree nil)))

    (defun bh/narrow-to-org-subtree ()
      (widen)
      (org-narrow-to-subtree))

    (defun bh/remove-empty-drawer-on-clock-out ()
      "Remove empty LOGBOOK drawers on clock out."
      (interactive)
      (save-excursion
        (beginning-of-line 0)
        (org-remove-empty-drawer-at "LOGBOOK" (point))))

    (defun bh/verify-refile-target ()
      "Exclude todo keywords with a done state from refile targets"
      (not (member (nth 2 (org-heading-components)) org-done-keywords)))

    (defun bh/find-project-task ()
      "Move point to the parent (project) task if any"
      (save-restriction
        (widen)
        (let ((parent-task (save-excursion (org-back-to-heading 'invisible-ok) (point))))
          (while (org-up-heading-safe)
            (when (member (nth 2 (org-heading-components)) org-todo-keywords-1)
              (setq parent-task (point))))
          (goto-char parent-task)
          parent-task)))

    (defun bh/is-project-p ()
      "Any task with a todo keyword subtask"
      (save-restriction
        (widen)
        (let ((has-subtask)
              (subtree-end (save-excursion (org-end-of-subtree t)))
              (is-a-task (member (nth 2 (org-heading-components)) org-todo-keywords-1)))
          (save-excursion
            (forward-line 1)
            (while (and (not has-subtask)
                        (< (point) subtree-end)
                        (re-search-forward "^\*+ " subtree-end t))
              (when (member (org-get-todo-state) org-todo-keywords-1)
                (setq has-subtask t))))
          (and is-a-task has-subtask))))

    (defun bh/is-project-subtree-p ()
      "Any task with a todo keyword that is in a project subtree.
Callers of this function already widen the buffer view."
      (let ((task (save-excursion (org-back-to-heading 'invisible-ok)
                                  (point))))
        (save-excursion
          (bh/find-project-task)
          (if (equal (point) task)
              nil
            t))))

    (defun ry/is-project-done-p ()
      "Determine if the current todo item is part of a project
that is done."
      (save-excursion
        (save-restriction
          (let ((project-task (bh/find-project-task)))
            (if (and project-task
                     (member (org-get-todo-state) org-done-keywords))
                t
              nil)))))

    (defun bh/is-task-p ()
      "Any task with a todo keyword and no subtask"
      (save-restriction
        (widen)
        (let ((has-subtask)
              (subtree-end (save-excursion (org-end-of-subtree t)))
              (is-a-task (member (nth 2 (org-heading-components)) org-todo-keywords-1)))
          (save-excursion
            (forward-line 1)
            (while (and (not has-subtask)
                        (< (point) subtree-end)
                        (re-search-forward "^\*+ " subtree-end t))
              (when (member (org-get-todo-state) org-todo-keywords-1)
                (setq has-subtask t))))
          (and is-a-task (not has-subtask)))))

    (defun bh/is-subproject-p ()
      "Any task which is a subtask of another project"
      (let ((is-subproject)
            (is-a-task (member (nth 2 (org-heading-components)) org-todo-keywords-1)))
        (save-excursion
          (while (and (not is-subproject) (org-up-heading-safe))
            (when (member (nth 2 (org-heading-components)) org-todo-keywords-1)
              (setq is-subproject t))))
        (and is-a-task is-subproject)))

    (defun bh/list-sublevels-for-projects-indented ()
      "Set org-tags-match-list-sublevels so when restricted to a subtree we list all subtasks.
  This is normally used by skipping functions where this variable is already local to the agenda."
      (if (marker-buffer org-agenda-restrict-begin)
          (setq org-tags-match-list-sublevels 'indented)
        (setq org-tags-match-list-sublevels nil))
      nil)

    (defun bh/list-sublevels-for-projects ()
      "Set org-tags-match-list-sublevels so when restricted to a subtree we list all subtasks.
  This is normally used by skipping functions where this variable is already local to the agenda."
      (if (marker-buffer org-agenda-restrict-begin)
          (setq org-tags-match-list-sublevels t)
        (setq org-tags-match-list-sublevels nil))
      nil)

    (defun bh/skip-stuck-projects ()
      "Skip trees that are not stuck projects"
      (save-restriction
        (widen)
        (let ((next-headline (save-excursion (or (outline-next-heading) (point-max)))))
          (if (bh/is-project-p)
              (let* ((subtree-end (save-excursion (org-end-of-subtree t)))
                     (has-next ))
                (save-excursion
                  (forward-line 1)
                  (while (and (not has-next) (< (point) subtree-end) (re-search-forward "^\\*+ NEXT " subtree-end t))
                    (unless (member "WAITING" (org-get-tags-at))
                      (setq has-next t))))
                (if has-next
                    nil
                  next-headline)) ; a stuck project, has subtasks but no next task
            nil))))

    (defun bh/skip-non-stuck-projects ()
      "Skip trees that are not stuck projects"
      (bh/list-sublevels-for-projects-indented)
      (save-restriction
        (widen)
        (let ((next-headline (save-excursion (or (outline-next-heading) (point-max)))))
          (if (bh/is-project-p)
              (let* ((subtree-end (save-excursion (org-end-of-subtree t)))
                     (has-next ))
                (save-excursion
                  (forward-line 1)
                  (while (and (not has-next) (< (point) subtree-end) (re-search-forward "^\\*+ NEXT " subtree-end t))
                    (unless (member "WAITING" (org-get-tags-at))
                      (setq has-next t))))
                (if has-next
                    next-headline
                  nil)) ; a stuck project, has subtasks but no next task
            next-headline))))

    (defun bh/skip-non-projects ()
      "Skip trees that are not projects"
      (bh/list-sublevels-for-projects-indented)
      (if (save-excursion (bh/skip-non-stuck-projects))
          (save-restriction
            (widen)
            (let ((subtree-end (save-excursion (org-end-of-subtree t))))
              (cond
               ((and (bh/is-project-p)
                     (marker-buffer org-agenda-restrict-begin))
                nil)
               ((and (bh/is-project-p)
                     (not (marker-buffer org-agenda-restrict-begin))
                     (not (bh/is-project-subtree-p)))
                nil)
               (t
                subtree-end))))
        (save-excursion (org-end-of-subtree t))))

    (defun bh/skip-project-trees-and-habits ()
      "Skip trees that are projects"
      (save-restriction
        (widen)
        (let ((subtree-end (save-excursion (org-end-of-subtree t))))
          (cond
           ((bh/is-project-p)
            subtree-end)
           ((org-is-habit-p)
            subtree-end)
           (t
            nil)))))

    (defun bh/skip-projects-and-habits-and-single-tasks ()
      "Skip trees that are projects, tasks that are habits, single non-project tasks"
      (save-restriction
        (widen)
        (let ((next-headline (save-excursion (or (outline-next-heading) (point-max)))))
          (cond
           ((org-is-habit-p)
            next-headline)
           ((bh/is-project-p)
            next-headline)
           ;; ((and (bh/is-task-p) (not (bh/is-project-subtree-p)))
           ;;  next-headline)
           (t
            nil)))))

    (defun bh/skip-project-tasks-maybe ()
      "Show tasks related to the current restriction.
When restricted to a project, skip project and sub project tasks, habits, NEXT tasks, and loose tasks.
When not restricted, skip project and sub-project tasks, habits, and project related tasks."
      (save-restriction
        (widen)
        (let* ((subtree-end (save-excursion (org-end-of-subtree t)))
               (next-headline (save-excursion (or (outline-next-heading) (point-max))))
               (limit-to-project (marker-buffer org-agenda-restrict-begin)))
          (cond
           ((bh/is-project-p)
            next-headline)
           ((org-is-habit-p)
            subtree-end)
           ((and (not limit-to-project)
                 (bh/is-project-subtree-p))
            subtree-end)
           ((and limit-to-project
                 (bh/is-project-subtree-p)
                 (member (org-get-todo-state) (list "NEXT")))
            subtree-end)
           (t
            nil)))))

    (defun ry/skip-non-projects-and-non-singletons ()
      "Skip tasks that are not projects and not 
singleton tasks."
      (save-restriction
        (widen)
        (let* ((subtree-end (save-excursion (org-end-of-subtree t)))
               (next-headline (save-excursion (or (outline-next-heading) (point-max))))
               (limit-to-project (marker-buffer org-agenda-restrict-begin)))
          (cond
           ((bh/is-project-p)
            nil)
           ((bh/is-project-subtree-p)
            subtree-end)
           ((org-is-habit-p)
            next-headline)
           (t
            nil)))))

    (defun bh/skip-projects-and-habits ()
      "Skip trees that are projects and tasks that are habits"
      (save-restriction
        (widen)
        (let ((subtree-end (save-excursion (org-end-of-subtree t))))
          (cond
           ((bh/is-project-p)
            subtree-end)
           ((org-is-habit-p)
            subtree-end)
           (t
            nil)))))

    (defun bh/skip-non-subprojects ()
      "Skip trees that are not projects"
      (let ((next-headline (save-excursion (outline-next-heading))))
        (if (bh/is-subproject-p)
            nil
          next-headline)))

    (defun bh/skip-non-archivable-tasks ()
      "Skip trees that are not available for archiving.
This was updated to treat subtasks the are part of project
that is not complete as unarchivable."
      (save-restriction
        (widen)
        (let ((next-headline (save-excursion (or (outline-next-heading) (point-max)))))
          ;; Consider only tasks with done todo headings as archivable candidates
          (if (and (ry/is-project-done-p)
                   (member (org-get-todo-state) org-done-keywords))
              (let* ((subtree-end (save-excursion (org-end-of-subtree t)))
                     (daynr (string-to-number (format-time-string "%d" (current-time))))
                     (a-month-ago (* 60 60 24 (+ daynr 1)))
                     (last-month (format-time-string "%Y-%m-" (time-subtract (current-time) (seconds-to-time a-month-ago))))
                     (this-month (format-time-string "%Y-%m-" (current-time)))
                     (subtree-is-current (save-excursion
                                           (forward-line 1)
                                           (and (< (point) subtree-end)
                                                (re-search-forward (concat last-month "\\|" this-month) subtree-end t)))))
                (if subtree-is-current
                    next-headline ; Has a date in this month or last month, skip it
                  nil))  ; available to archive
            (or next-headline (point-max))))))

    (defun bh/org-agenda-to-appt ()
      "Erase all reminders and rebuilt reminders for today from the agenda."
      (interactive)
      (setq appt-time-msg-list nil)
      (org-agenda-to-appt))

    (defvar bh/current-view-project nil)

    (defun bh/agenda-sort (a b)
      "Sorting strategy for agenda items.
Late deadlines first, then scheduled, then non-late deadlines"
      (let (result num-a num-b)
        (cond
                                        ; time specific items are already sorted first by org-agenda-sorting-strategy
                                        ; non-deadline and non-scheduled items next
         ((bh/agenda-sort-test 'bh/is-not-scheduled-or-deadline a b))

                                        ; deadlines for today next
         ((bh/agenda-sort-test 'bh/is-due-deadline a b))

                                        ; late deadlines next
         ((bh/agenda-sort-test-num 'bh/is-late-deadline '< a b))

                                        ; scheduled items for today next
         ((bh/agenda-sort-test 'bh/is-scheduled-today a b))

                                        ; late scheduled items next
         ((bh/agenda-sort-test-num 'bh/is-scheduled-late '> a b))

                                        ; pending deadlines last
         ((bh/agenda-sort-test-num 'bh/is-pending-deadline '< a b))

                                        ; finally default to unsorted
         (t (setq result nil)))
        result))

    (defmacro bh/agenda-sort-test (fn a b)
      "Test for agenda sort"
      `(cond
                                        ; if both match leave them unsorted
        ((and (apply ,fn (list ,a))
              (apply ,fn (list ,b)))
         (setq result nil))
                                        ; if a matches put a first
        ((apply ,fn (list ,a))
         (setq result -1))
                                        ; otherwise if b matches put b first
        ((apply ,fn (list ,b))
         (setq result 1))
                                        ; if none match leave them unsorted
        (t nil)))

    (defmacro bh/agenda-sort-test-num (fn compfn a b)
      `(cond
        ((apply ,fn (list ,a))
         (setq num-a (string-to-number (match-string 1 ,a)))
         (if (apply ,fn (list ,b))
             (progn
               (setq num-b (string-to-number (match-string 1 ,b)))
               (setq result (if (apply ,compfn (list num-a num-b))
                                -1
                              1)))
           (setq result -1)))
        ((apply ,fn (list ,b))
         (setq result 1))
        (t nil)))

    (defun bh/is-not-scheduled-or-deadline (date-str)
      (and (not (bh/is-deadline date-str))
           (not (bh/is-scheduled date-str))))

    (defun bh/is-due-deadline (date-str)
      (string-match "Deadline:" date-str))

    (defun bh/is-late-deadline (date-str)
      (string-match "In *\\(-.*\\)d\.:" date-str))

    (defun bh/is-pending-deadline (date-str)
      (string-match "In \\([^-]*\\)d\.:" date-str))

    (defun bh/is-deadline (date-str)
      (or (bh/is-due-deadline date-str)
          (bh/is-late-deadline date-str)
          (bh/is-pending-deadline date-str)))

    (defun bh/is-scheduled (date-str)
      (or (bh/is-scheduled-today date-str)
          (bh/is-scheduled-late date-str)))

    (defun bh/is-scheduled-today (date-str)
      (string-match "Scheduled:" date-str))

    (defun bh/is-scheduled-late (date-str)
      (string-match "Sched\.\\(.*\\)x:" date-str))

    (defun bh/insert-inactive-timestamp ()
      (interactive)
      (org-insert-time-stamp nil t t nil nil nil))

    (defun bh/insert-heading-inactive-timestamp ()
      (save-excursion
        (org-return)
        (org-cycle)
        (bh/insert-inactive-timestamp)))

    (defun bh/mark-next-parent-tasks-todo ()
      "Visit each parent task and change NEXT states to TODO"
      (let ((mystate (or (and (fboundp 'org-state)
                              state)
                         (nth 2 (org-heading-components)))))
        (when mystate
          (save-excursion
            (while (org-up-heading-safe)
              (when (member (nth 2 (org-heading-components)) (list "NEXT"))
                (org-todo "TODO")))))))))
#+END_SRC

* Company Mode

Completion is done using Company mode.  I was originally using Auto Complete but switched to Company.  I cannot remember the reason for the switch but the config is gone now so I am here to stay unless there is some big reason to switch back.

The main modification is to use C-n and C-p to cycle through candidates and the faces for the popup.  The faces are done using the color package so that it fits in with my theme.

#+BEGIN_SRC emacs-lisp :tangle yes :exports code
(use-package company
  :ensure t
  :diminish company-mode
  :demand
  :bind (:map company-active-map
              ("M-n" . nil)
              ("M-p" . nil)
              ("C-n" . company-select-next)
              ("C-p" . company-select-previous))
  :config
  (progn
    (global-company-mode)

    (setq company-idle-delay                 nil
          company-show-numbers               t
          company-selection-wrap-around      t
          company-tooltip-limit              10
          company-tooltip-flip-when-above    t
          company-dabbrev-downcase           nil
          company-dabbrev-ignore-invisible   t
          company-dabbrev-ignore-buffers     "\\`[ ]'"
          company-dabbrev-code-ignore-case   t
          company-dabbrev-code-other-buffers 'all
          company-dabbrev-other-buffers      'all
          company-tooltip-align-annotations  t)

    ;;  Only load the work related company backend if I am at work.
    ;; (when (at-work-p)
    ;;   (add-to-list 'load-path "~/.emacs.d/extra")
    ;;   (require 'ry-company-sql)    
    ;;   (add-to-list 'company-backends 'ry/company-sql))

    ;; Add yasnippet support for all company backends
    ;; https://github.com/syl20bnr/spacemacs/pull/179
    (defvar company-mode/enable-yas t
      "Enable yasnippet for all backends.")

    (defun company-mode/backend-with-yas (backend)
      (if (or (not company-mode/enable-yas) (and (listp backend) (member 'company-yasnippet backend)))
          backend
        (append (if (consp backend) backend (list backend))
                '(:with company-yasnippet))))

    (setq company-backends (mapcar #'company-mode/backend-with-yas company-backends))

    ;; (require 'color)
    ;; (let ((bg (face-attribute 'default :background)))
    ;;   (set-face-attribute 'company-tooltip nil
    ;;                       :inherit 'default
    ;;                       :background (color-lighten-name bg 2))
    ;;   (set-face-attribute 'company-scrollbar-bg nil
    ;;                       :background (color-lighten-name bg 10))
    ;;   (set-face-attribute 'company-scrollbar-fg nil
    ;;                       :background (color-lighten-name bg 5))
    ;;   (set-face-attribute 'company-tooltip-selection nil
    ;;                       :inherit font-lock-function-name-face)
    ;;   (set-face-attribute 'company-tooltip-common nil
    ;;                       :inherit font-lock-constant-face))

    ;;  Use TAB to perform completion using yasnippet and company.
    ;;  https://www.emacswiki.org/emacs/CompanyMode#toc10
    (defun check-expansion ()
      (save-excursion
        (if (looking-at "\\_>") t
          (backward-char 1)
          (if (looking-at "\\.") t
            (backward-char 1)
            (if (looking-at "->") t nil)))))

    (defun do-yas-expand ()
      (let ((yas-fallback-behavior 'return-nil))
        ;; (yas-expand) 
        (company-yasnippet nil)))

    (defun tab-indent-or-complete ()
      (interactive)
      (if (minibufferp)
          (minibuffer-complete)
        (if (or (not yas-minor-mode)
                (null (do-yas-expand)))
            (if (check-expansion)
                (company-complete-common)
              (indent-for-tab-command)))))

    (global-set-key [tab] 'tab-indent-or-complete)))
#+END_SRC

Company quickhelp is handy so load it after company mode.

#+BEGIN_SRC emacs-lisp :tangle yes :exports code
(use-package company-quickhelp
  :ensure t
  :after company
  :config
  (progn
    (company-quickhelp-mode 1)
    (setq company-quickhelp-delay 0.1)))
#+END_SRC

* Paredit

#+BEGIN_SRC emacs-lisp :tangle yes :exports code
(use-package paredit
  :ensure t
  :commands paredit-mode
  :diminish "()"
  :bind (:map paredit-mode-map
              ("M-)" . paredit-forward-slurp-sexp)
              ("C-(" . paredit-forward-barf-sexp)
              ("C-)" . paredit-forward-slurp-sexp)
              (")" . paredit-close-parenthesis)))

;;  Pair characters
(electric-pair-mode 1)
(setq electric-pair-preserve-balance t
      electric-pair-delete-adjacent-pairs t
      electric-pair-open-newline-between-pairs nil)

;;  Show where matching parens are.
(show-paren-mode 1)
(setq show-paren-style 'parenthesis)
#+END_SRC

* Smartparens
   
This Smartparens configuration was taken from https://github.com/mwfogleman/config/blob/master/home/.emacs.d/michael.org and http://pages.sachachua.com/.emacs.d/Sacha.html, https://raw.githubusercontent.com/Fuco1/.emacs.d/master/files/smartparens.el, and [[https://raw.githubusercontent.com/Fuco1/.emacs.d/master/files/smartparens.el]].  I am still trying to incorporate the package into my workflow.  It seems that it will be a very powerful addition to my work.

#+BEGIN_SRC emacs-lisp :tangle yes :exports code
(use-package smartparens-config
  :ensure smartparens
  :disabled t
  :diminish smartparens-mode
  ;; :demand t
  :bind (
     ("C-M-a" . sp-beginning-of-sexp)
     ("C-M-e" . sp-end-of-sexp)
     ("C-<down>" . sp-down-sexp)
     ("C-<up>"   . sp-up-sexp)
     ("M-<down>" . sp-backward-down-sexp)
     ("M-<up>"   . sp-backward-up-sexp)
     ("C-M-f" . sp-forward-sexp)
     ("C-M-b" . sp-backward-sexp)
     ("C-M-n" . sp-next-sexp)
     ("C-M-p" . sp-previous-sexp)
     ("C-S-f" . sp-forward-symbol)
     ("C-S-b" . sp-backward-symbol)
     ("C-<right>" . sp-forward-slurp-sexp)
     ("M-<right>" . sp-forward-barf-sexp)
     ("C-<left>"  . sp-backward-slurp-sexp)
     ("M-<left>"  . sp-backward-barf-sexp)
     ("C-M-t" . sp-transpose-sexp)
     ("C-M-k" . sp-kill-sexp)
     ("C-k"   . sp-kill-hybrid-sexp)
     ("M-k"   . sp-backward-kill-sexp)
     ("C-M-w" . sp-copy-sexp)
     ("C-M-d" . delete-sexp)
     ("M-<backspace>" . backward-kill-word)
     ("C-<backspace>" . sp-backward-kill-word)  ([remap sp-backward-kill-word] . backward-kill-word)
     ("M-[" . sp-backward-unwrap-sexp)
     ("M-]" . sp-unwrap-sexp)
     ("C-x C-t" . sp-transpose-hybrid-sexp)
     ("C-c ("  . wrap-with-parens)
     ("C-c ["  . wrap-with-brackets)
     ("C-c {"  . wrap-with-braces)
     ("C-c '"  . wrap-with-single-quotes)
     ("C-c \"" . wrap-with-double-quotes)
     ("C-c _"  . wrap-with-underscores)
     ("C-c `"  . wrap-with-back-quotes))
  :config
  (progn
    (require 'smartparens-config)
    
    ;;  org-mode config.
    ;; (sp-with-modes 'org-mode
    ;;   (sp-local-pair "*" "*" :actions '(insert wrap) :unless '(sp-point-after-word-p sp-point-at-bol-p) :wrap "C-*" :skip-match 'sp--org-skip-asterisk)
    ;;   (sp-local-pair "_" "_" :unless '(sp-point-after-word-p) :wrap "C-_")
    ;;   (sp-local-pair "/" "/" :unless '(sp-point-after-word-p) :post-handlers '(("[d1]" "SPC")))
    ;;   (sp-local-pair "~" "~" :unless '(sp-point-after-word-p) :post-handlers '(("[d1]" "SPC")))
    ;;   (sp-local-pair "=" "=" :unless '(sp-point-after-word-p) :post-handlers '(("[d1]" "SPC")))
    ;;   (sp-local-pair "" ""))

    ;; (defun sp--org-skip-asterisk (ms mb me)
    ;;   (or (and (= (line-beginning-position) mb)
    ;;            (eq 32 (char-after (1+ mb))))
    ;;       (and (= (1+ (line-beginning-position)) me)
    ;;            (eq 32 (char-after me)))))

    ;;  lisp-modes config
    ;; (sp-with-modes sp-lisp-modes
    ;;   (sp-local-pair "(" nil
    ;;                  :wrap "C-("
    ;;                  :pre-handlers '(my-add-space-before-sexp-insertion)
    ;;                  :post-handlers '(my-add-space-after-sexp-insertion)))
   
    ;; (defun my-add-space-after-sexp-insertion (id action _context)
    ;;   (when (eq action 'insert)
    ;;     (save-excursion
    ;;       (forward-char (sp-get-pair id :cl-l))
    ;;       (when (or (eq (char-syntax (following-char)) ?w)
    ;;                 (looking-at (sp--get-opening-regexp)))
    ;;         (insert " ")))))

    ;; (defun my-add-space-before-sexp-insertion (id action _context)
    ;;   (when (eq action 'insert)
    ;;     (save-excursion
    ;;       (backward-char (length id))
    ;;       (when (or (eq (char-syntax (preceding-char)) ?w)
    ;;                 (and (looking-back (sp--get-closing-regexp))
    ;;                      (not (eq (char-syntax (preceding-char)) ?'))))
    ;;         (insert " ")))))
    
    ;;  java-mode config.
    ;; (sp-with-modes 'java-mode
    ;;   (sp-local-pair "{" nil :post-handlers '(("||\n[i]" "RET")))
    ;;   (sp-local-pair "/*" "*/" :post-handlers '((" | " "SPC")
    ;;                                             ("* ||\n[i]" "RET"))))

    ;;  nxml-mode config.
    ;; (sp-with-modes 'nxml-mode     
    ;;   (sp-local-pair "<!--" "-->")
    ;;   (sp-local-pair "<" ">"))
    
    ;;  web-mode config.
    ;; (sp-with-modes 'web-mode
    ;;   (sp-local-pair "<!--" "-->")
    ;;   (sp-local-pair "<%--" "--%>"))
    ))
#+END_SRC

* Yasnippet

Plain old yasnippet configuration.  The second part is to enable selection based on a popup menu.

#+BEGIN_SRC emacs-lisp :tangle yes :exports code
(use-package yasnippet
  :ensure t
  :diminish yas-minor-mode
  :config
  (progn
    (yas-load-directory "~/.emacs.d/snippets")
    (yas-global-mode 1)
    

    ;;; use popup menu for yas-choose-value
    (use-package popup
      :ensure t)

    (defun yas-popup-isearch-prompt (prompt choices &optional display-fn)
      (when (featurep 'popup)
        (popup-menu*
         (mapcar
          (lambda (choice)
            (popup-make-item
             (or (and display-fn (funcall display-fn choice))
                 choice)
             :value choice))
          choices)
         :prompt prompt
         ;; start isearch mode immediately
         :isearch t
         )))

    (setq yas-prompt-functions '(yas-popup-isearch-prompt yas-ido-prompt yas-no-prompt))))
#+END_SRC

Add helm-c-yasnippet so that snippets for the major mode can be seen easily.

#+BEGIN_SRC emacs-lisp :tangle yes :exports code
(use-package helm-c-yasnippet
  :ensure t
  :disabled t
  :bind (("C-c y" . helm-yas-complete))
  :config
  (setq helm-yas-space-match-any-greedy t))
#+END_SRC

* Magit
   
The only reason I use git is to save this configuration, but I can see how this mode could be very useful.  Perhaps someday work will make the switch.  This configuration was taken from https://github.com/mwfogleman/config/blob/master/home/.emacs.d/michael.org.

#+BEGIN_SRC emacs-lisp :tangle yes :exports code
(use-package magit
  :ensure t
  :bind (("C-x g" . magit-status)
         ("C-c g" . magit-status))
  :bind (:map magit-status-mode-map
              ("TAB" . magit-section-toggle)
              ("<C-tab>" . magit-section-cycle)
              ("q" . magit-quit-session))
  :config
  (progn
    (setq magit-use-overlays nil
          magit-completing-read-function 'ivy-completing-read
          magit-last-seen-setup-instructions "1.4.0")

    (setenv "GIT_ASKPASS" "git-gui--askpass")
    
    (defadvice magit-status (around magit-fullscreen activate)
      (window-configuration-to-register :magit-fullscreen)
      ad-do-it
      (delete-other-windows))
    
    (defun magit-quit-session ()
      "Restores the previous window configuration and kills the magit buffer"
      (interactive)
      (kill-buffer)
      (jump-to-register :magit-fullscreen))

    ;; (bind-keys :map magit-status-mode-map
    ;;            ("TAB" . magit-section-toggle)
    ;;            ("<C-tab>" . magit-section-cycle)
    ;;            ("q" . magit-quit-session))
    ))
#+END_SRC

Add Git diff information to the gutter so that I can easily track changes.

#+BEGIN_SRC emacs-lisp :tangle yes :exports code
(use-package git-gutter+
  :ensure t
  :commands git-gutter+-mode
  :diminish git-gutter+-mode
  :config
  (progn
    (setq git-gutter+-modified-sign "  ") ;; two space
    (setq git-gutter+-added-sign "++")    ;; multiple character is OK
    (setq git-gutter+-deleted-sign "--")
    (set-face-background 'git-gutter+-modified "#073642")))
#+END_SRC

* Programming
** Environment
   
Make delimiters a little easier to match up without having to be on one of them.  Also a tip found [[http://timothypratley.blogspot.com/2015/07/seven-specialty-emacs-settings-with-big.html][here]] for making unmatched parentheses easier to see.  Also This uses some pastel colors that I found [[http://web.ics.purdue.edu/~dogbe/static/emacs_config_file.html][here]].

#+BEGIN_SRC emacs-lisp :tangle yes :exports code
(use-package rainbow-delimiters
  :ensure t 
  :config
  (progn
    (add-hook 'prog-mode-hook 'rainbow-delimiters-mode)

    (set-face-attribute 'rainbow-delimiters-depth-1-face nil
                        :foreground "#78c5d6")
    (set-face-attribute 'rainbow-delimiters-depth-2-face nil
                        :foreground "#bf62a6")
    (set-face-attribute 'rainbow-delimiters-depth-3-face nil
                        :foreground "#459ba8")
    (set-face-attribute 'rainbow-delimiters-depth-4-face nil
                        :foreground "#e868a2")
    (set-face-attribute 'rainbow-delimiters-depth-5-face nil
                        :foreground "#79c267")
    (set-face-attribute 'rainbow-delimiters-depth-6-face nil
                        :foreground "#f28c33")
    (set-face-attribute 'rainbow-delimiters-depth-7-face nil
                        :foreground "#c5d647")
    (set-face-attribute 'rainbow-delimiters-depth-8-face nil
                        :foreground "#f5d63d")
    (set-face-attribute 'rainbow-delimiters-depth-9-face nil
                        :foreground "#78c5d6")
    
    (set-face-attribute 'rainbow-delimiters-unmatched-face nil
                        :foreground 'unspecified
                        :inherit 'error)))
#+END_SRC

Smartscan mode allows for finding the next/previous occurrence of the symbol under point.  

#+BEGIN_SRC emacs-lisp :tangle yes :exports code
(use-package smartscan
  :ensure t
  :commands (smartscan-symbol-go-forward smartscan-symbol-go-backward)
  :bind (("M-n" . smartscan-symbol-go-forward)
         ("M-p" . smartscan-symbol-go-backward))
  :config
  (add-hook 'prog-mode-hook 'smartscan-mode))
#+END_SRC

Enable Eldoc for Lisp modes.

#+BEGIN_SRC emacs-lisp :tangle yes :exports code
(use-package "eldoc"  
  :diminish eldoc-mode
  :init
  :bind (:map edebug-mode-map
              ("A" . my-elisp-add-to-watch))
  (progn
    (setq eldoc-idle-delay 0.2)

    ;; define a key
    (define-key edebug-mode-map "A" 'my-elisp-add-to-watch)

    ;; the implementation
    (defun my-elisp-add-to-watch (&optional region-start region-end)
      "Add the current variable to the *EDebug* window"
      (interactive "r")
      (let ((statement (if (and region-start region-end (use-region-p))
                           (buffer-substring region-start region-end)
                         (symbol-name (eldoc-current-symbol)))))

        ;; open eval buffer
        (edebug-visit-eval-list)

        ;; jump to the end of it and add a newline
        (goto-char (point-max)) (newline)

        ;; insert the variable
        (insert statement)

        ;; update the list
        (edebug-update-eval-list)

        ;; jump back to where we were
        (edebug-where)))
    
    (add-hook 'emacs-lisp-mode-hook 'turn-on-eldoc-mode)
    (add-hook 'lisp-interaction-mode-hook 'turn-on-eldoc-mode)
    (add-hook 'ielm-mode-hook 'turn-on-eldoc-mode)))
#+END_SRC

Commenting should be DWIM.

#+BEGIN_SRC emacs-lisp :tangle yes :exports code
(use-package comment-dwim-2
  :ensure t
  :bind (("M-;" . comment-dwim-2)))
#+END_SRC

On-the-fly syntax checking.  I included this when I added Eclim.  Not sure if it is really needed as the syntax highlighing is not working.  Maybe I will look in to it.

#+BEGIN_SRC emacs-lisp :tangle yes :exports code
(use-package flycheck
  :ensure t
  :commands (flycheck-mode))
#+END_SRC

Used for displaying errors in a popup.

#+BEGIN_SRC emacs-lisp :tangle yes :exports code
(use-package flycheck-pos-tip
  :ensure t
  :after flycheck
  :config
  (flycheck-pos-tip-mode))
#+END_SRC

This package is used to display the various members while working in eclim.

#+BEGIN_SRC emacs-lisp :tangle yes :exports code
(use-package imenu-list
  :ensure t
  :after eclim
  :config
  (progn
    (setq imenu-list-position 'left)
    (setq imenu-list-auto-resize nil)))
#+END_SRC

Used to create a "workspace" for Java development.

#+BEGIN_SRC emacs-lisp :tangle yes :exports code
(use-package neotree
  :ensure t
  :disabled t
  :bind (("<f11>" . neotree-toggle))
  :config
  (progn
    (setq neo-smart-open t)

    (when neo-persist-show
    (add-hook 'popwin:before-popup-hook
              #'(lambda () (setq neo-persist-show nil)))
    (add-hook 'popwin:after-popup-hook
              #'(lambda () (setq neo-persist-show t))))))
#+END_SRC

** Languages
*** Java

And then there is emacs-eclim.  This took a lot of experimentation to get working.  Even though it is working the way that it is working is not the best.  There are a number of comments in the code that detail why things were done the way there were.  

I wonder if the issue for the problems is that I am running an old version of Eclipse or the fact that the machine that I do my Java work is a Windows one.  I would have to imagine it is a little of both.

The changes that were made to get it working are not pretty.  

#+BEGIN_SRC emacs-lisp :tangle yes :exports code
;; (when (at-work-p))
(use-package eclim
  :disabled t
  :ensure t
  :bind (:map eclim-mode-map
              ("M-/" . company-emacs-eclim)
              ("M-." . eclim-java-find-declaration))
  :init
  (progn
    (setq-default eclim--problems-filter "e")
    (global-eclim-mode))
  :config
  (progn
    (setq help-at-pt-display-when-idle t)
    (setq help-at-pt-timer-delay 0.1)
    (help-at-pt-set-timer)

    (set-face-attribute 'eclim-problems-highlight-error-face nil
                        :underline '(:style wave :color "#E10080"))

    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;      
    ;;  Show positions in problems buffer.
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;      
    (setq eclim-problems-show-pos t)     

    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ;;  Use the company backend that comes with eclim.
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;      
    ;;(company-emacs-eclim-setup)         

    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;      
    ;;  Ignore case when getting completion options.
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    (setq company-emacs-eclim-ignore-case t)

    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ;;  Toggle debugging.
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ;; (eclim-toggle-print-debug-messages)
    
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ;;  Windows setup so that eclim knows where the bat file is.
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    (custom-set-variables
     '(eclim-eclipse-dirs '("C:/IBM/SDP"))
     '(eclim-executable "C:/IBM/SDP/eclim.bat")
     '(company-eclim-executable "C:/IBM/SDP/eclim.bat"))))
#+END_SRC

Enable subword mode for Java.

#+BEGIN_SRC emacs-lisp :tangle yes :exports code
(add-hook 'java-mode-hook
          #'(lambda ()
              (subword-mode 1)
              (local-set-key (kbd "RET") 'c-indent-new-comment-line)
              (setq c-comment-prefix-regexp "//+\\|/?\\**")
            
              (let ((c-buffer-is-cc-mode t))
                (c-setup-paragraph-variables))))

#+END_SRC

*** Lisp

Lisp mode hooks for cask files for if/when I start looking in to cask.

#+BEGIN_SRC emacs-lisp :tangle yes :exports code
(use-package lisp-mode
  :mode ("Cask\\'" . emacs-lisp-mode)
  :config
  (progn
    (add-hook 'emacs-lisp-mode-hook #'(lambda ()
                                        (eldoc-mode 1)
                                        (paredit-mode 1)))))
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle yes :exports code
(use-package slime
  :ensure t
  :if (not (at-work-p))
  :mode 
  (("\\.lisp\\'" . lisp-mode)
   ("\\.cl\\'"   . lisp-mode))
  :config
  (progn
    (load (expand-file-name ".quicklisp/slime-helper.el"))
    (setq inferior-lisp-program "/usr/local/bin/sbcl")))
#+END_SRC

*** Clojure

I do not write Clojure code but I would like to learn when time permits.

#+BEGIN_SRC emacs-lisp :tangle yes :exports code
(use-package cider
  :ensure t
;;  :if (not (at-work-p))
  :disabled t
  :bind (("<f10>" . cider-jack-in))
  :config
  (progn
    (add-hook 'cider-mode-hook #'eldoc-mode)
    (setq nrepl-hide-special-buffers t)
    (setq cider-repl-tab-command #'indent-for-tab-command)
    (add-hook 'cider-repl-mode-hook #'subword-mode)))
#+END_SRC

*** Haskell

#+BEGIN_SRC emacs-lisp :tangle yes :exports code
(use-package intero
  ;;:ensure t
  ;;:if (not (at-work-p))
  :disabled t
  :config
  (add-hook 'haskell-mode-hook 'intero-mode))
#+END_SRC

*** Web

Enable web mode for various file extensions.

#+BEGIN_SRC emacs-lisp :tangle yes :exports code
(use-package web-mode
  :ensure t
  :mode 
  (("\\.phtml\\'" . web-mode)
   ("\\.tpl\\.php\\'" . web-mode)
   ("\\.jsp\\'" . web-mode)
   ("\\.as[cp]x\\'" . web-mode)
   ("\\.erb\\'" . web-mode)
   ("\\.mustache\\'" . web-mode)
   ("\\.djhtml\\'" . web-mode))
  :init
  (setq web-mode-enable-auto-pairing nil)
  :config
  (progn
    (defun my/web-mode-hook ()
      (setq web-mode-enable-auto-pairing nil))

    ;; (defun sacha/sp-web-mode-is-code-context (id action context)
    ;;   (when (and (eq action 'insert)
    ;;              (not (or (get-text-property (point) 'part-side)
    ;;                       (get-text-property (point) 'block-side))))
    ;;     t))
    ))
#+END_SRC

*** JSON Reformat

Work requires me to work with JSON objects every blue moon.  Being able to pretty print them is a good thing.

#+BEGIN_SRC emacs-lisp :tangle yes :exports code
(use-package json-reformat
  :ensure t
  :commands (json-pretty-print json-pretty-print-buffer))
#+END_SRC

* Misc. Packages
** Paradox

Being able to use Emacs while packages are updated is a fantastic thing.  Paradox makes this happen.  The async package should be brought in automatically but for some reason it is here anyway.

#+BEGIN_SRC emacs-lisp :tangle yes :exports code
(use-package async
  :ensure t)

(use-package paradox
  :ensure t
  :commands (paradox-mode paradox-upgrade-packages)
  :config
  (progn
    (setq paradox-execute-asynchronously t)
    (setq paradox-github-token t)))
#+END_SRC

** Diminish
   
Diminish reduces the clutter from the mode-line.  Just as with the async package, it really should be brought in as a dependency of another (use-package).

#+BEGIN_SRC emacs-lisp :tangle yes :exports code
(use-package diminish
  :ensure t)
#+END_SRC

** Htmlize

Pretty print of exported documents.

#+BEGIN_SRC emacs-lisp :tangle yes :exports code
(use-package htmlize
  :ensure t
  :commands (htmlize-file htmlize-buffer htmlize-region))
#+END_SRC

** Golden Ratio

Use the golden ratio to size windows when multiples are open.

#+BEGIN_SRC emacs-lisp :tangle yes :exports code
(use-package golden-ratio
  :ensure t
  :diminish golden-ratio-mode
  :config
  (progn 
    (golden-ratio-mode)
    (setq golden-ratio-exclude-modes
          '("dired-mode"
            "ediff-mode"
            "eshell-mode"
            "messages-buffer-mode"
            "fundamental-mode"
            "imenu-list-major-mode"))
    ;; (defun my/helm-alive-p ()
    ;;   (if (boundp 'helm-alive-p)
    ;;       (symbol-value 'helm-alive-p)))
    ;; (add-to-list 'golden-ratio-inhibit-functions #'my/helm-alive-p)
    ))
#+END_SRC

** Hydra

Hyrda is a very cool package.  Prior to hydra I was using custom maps for a couple small groups of related commands.  The original configuration was similar to the one here, https://github.com/mwfogleman/config/blob/master/home/.emacs.d/michael.org.  Hydra has taken over this duty and I have a couple more uses in mind as well.

Whitespace mode was marked as required so that the mode toggle hydra would work correctly.

#+BEGIN_SRC emacs-lisp :tangle yes :exports code
(use-package hydra
  :ensure t
  :disabled t
  :commands (hydra-toggle/body hydra-launch/body hydra-xml/body)
  :bind (("C-c t" . hydra-toggle/body)
         ("C-c l" . hydra-launch/body)
         ("C-c x" . hydra-xml/body))
  :config
  (progn
    (require 'whitespace)
    
    ;;  Change the blue face color as it is hard to see in Solarized dark.
    (set-face-attribute 'hydra-face-blue nil
                        :foreground "#4169e1")
    
    (defhydra hydra-toggle (:color pink)
      "
_a_bbrev-mode:         %`abbrev-mode
_m_enu-bar-mode:       %`menu-bar-mode
_d_ebug-on-error:      %`debug-on-error
_f_lyspell-mode:       %`flyspell-mode
_g_lobal-hl-line-mode: %`global-hl-line-mode
_w_hitepace-mode:      %`whitespace-mode
_s_martparens-mode:    %`smartparens-mode

"
      ("a" abbrev-mode nil)
      ("m" menu-bar-mode nil)
      ("d" toggle-debug-on-error nil)
      ("f" flyspell-mode nil)
      ("g" global-hl-line-mode nil)
      ("s" smartparens-mode nil)
      ("w" whitespace-mode nil)
      ("q" nil "cancel"))

    (defhydra hydra-launch (:color blue)
      "
_i_nternet Explorer
_w_indows Explorer

"
      ("i" ry/launch-internet-explorer nil)
      ("w" ry/launch-windows-explorer nil)
      ("q" nil "cancel" :color red))

    (defhydra hydra-xml (:color blue)
      "
_f_ormat
_l_inearlize
_w_here
_x_query buffer

"
      ("f" ry/xml-format nil)
      ("l" ry/xml-linearlize nil)
      ("w" ry/xml-where nil)
      ("x" ry/xquery nil)
      ("q" nil "cancel" :color red))

    (defhydra hydra-clock (:color blue)
      "
_1_ Punch in            _3_ Clock in
_2_ Punch out           _4_ Clock out
                      _5_ Clock goto
"
      ("1" bh/punch-in)
      ("2" bh/punch-out)
      ("3" org-clock-in nil)
      ("4" org-clock-out nil)
      ("5" org-clock-goto nil))

    (defhydra cqql-multiple-cursors-hydra (:hint nil)
      "
     ^Up^            ^Down^        ^Miscellaneous^
----------------------------------------------
[_p_]   Next    [_n_]   Next    [_l_] Edit lines
[_P_]   Skip    [_N_]   Skip    [_a_] Mark all
[_M-p_] Unmark  [_M-n_] Unmark  [_q_] Quit"
  ("l" mc/edit-lines :exit t)
  ("a" mc/mark-all-like-this :exit t)
  ("n" mc/mark-next-like-this)
  ("N" mc/skip-to-next-like-this)
  ("M-n" mc/unmark-next-like-this)
  ("p" mc/mark-previous-like-this)
  ("P" mc/skip-to-previous-like-this)
  ("M-p" mc/unmark-previous-like-this)
  ("q" nil))


    (global-set-key (kbd "C-c t") 'hydra-toggle/body)
    (global-set-key (kbd "C-c l") 'hydra-launch/body)
    (global-set-key (kbd "C-c x") 'hydra-xml/body)
    (global-set-key (kbd "C-c m") 'cqql-multiple-cursors-hydra/body)))
    ;;(global-set-key (kbd "<f9>") 'hydra-clock/body)

#+END_SRC

** Eww Lnum

Add numbers to links in web pages when using Eww the same way that Surf or other minimal web browsers do.  I don't use eww very often but it is helpful when I do.

#+BEGIN_SRC emacs-lisp :tangle yes :exports code
(use-package eww-lnum
  :ensure t
  :commands eww
  :bind (:map eww-mode-map
              ("f" . eww-lnum-follow)
              ("F" . eww-lnum-universal))
  ;; :init
  ;; (eval-after-load "eww"
  ;;   '(progn (define-key eww-mode-map "f" 'eww-lnum-follow)
  ;;           (define-key eww-mode-map "F" 'eww-lnum-universal)))
  )
#+END_SRC

** Stackexchange

Everyone uses Stackexchange.  Why not interact with it through Emacs.

#+BEGIN_SRC emacs-lisp :tangle yes :exports code 
(use-package sx
  :ensure t
  :commands (sx-tab-feature sx-tab-frontpage sx-tab-hot sx-tab-newest sx-tab))
#+END_SRC

** Re-builder

Visual regular expression building.

#+BEGIN_SRC emacs-lisp :tangle yes :exports code
(use-package re-builder
  :ensure t
  :commands (re-builder)
  :config
  (setq reb-re-syntax 'string))
#+END_SRC

** Popwin

Fix annoying buffer popups.

#+BEGIN_SRC emacs-lisp :tangle yes :exports code
(use-package popwin
  :ensure t
  :disabled t
  :config
  (popwin-mode))
#+END_SRC

** Discover My Major

Helps to discover keybindings for the current mode.

#+BEGIN_SRC emacs-lisp :tangle yes :exports code
(use-package discover-my-major
  :ensure t
  :disabled t
  :commands discover-my-major)
#+END_SRC

** Log4j

I previously had this in my configuration to make looking at log files easier.  I cannot remember why it was removed.  It's being added back to determine if it is helpful or not.

#+BEGIN_SRC emacs-lisp :tangle yes :exports code
(use-package log4j-mode
  :mode 
  (("\\.log\\(\\.[0-9]+\\)?\\(\\.txt\\)?\\'" . log4j-mode))
  :ensure t
  :disabled t
  :config
  (add-hook 'log4j-mode-hook #'(lambda () 
                                 (visual-line-mode 1)
                                 (hl-line-mode 1))))
#+END_SRC

** Unkillable scratch
   
   Prevent me from accidentally killing the **scratch** buffer.

#+BEGIN_SRC emacs-lisp :tangle yes :exports code
(use-package unkillable-scratch
  :ensure t
  :disabled t
  :config
  (progn
    (unkillable-scratch)))
#+END_SRC

** Beacon

#+BEGIN_SRC emacs-lisp :tangle yes :exports code
(use-package beacon
  :ensure t
  :init
  (beacon-mode))
#+END_SRC

* Documentation

Why not have SICP in emacs for easy reading?

#+BEGIN_SRC emacs-lisp :tangle yes :exports code
(use-package sicp
  :ensure t
  :disabled t)
#+END_SRC 

* Disabled packages
** Hl-line+

#+BEGIN_SRC emacs-lisp :tangle yes :exports code
(use-package hl-line+
;;  :ensure t
  :disabled t
  :config
  (progn
    (global-hl-line-mode nil)
    (toggle-hl-line-when-idle 0)
    (hl-line-when-idle-interval 3)))
#+END_SRC

** Spaceline

#+BEGIN_SRC emacs-lisp :tangle yes :exports code
(use-package spaceline
  ;; :ensure t
  :disabled t
  :init
  (setq powerline-default-separator 'arrow-fade)
  :config
  (require 'spaceline-config)
  (spaceline-spacemacs-theme)
  (spaceline-helm-mode))
#+END_SRC

** Origami

A nicer way to fold.

#+BEGIN_SRC emacs-lisp :tangle yes :exports code
(use-package origami
;;  :ensure t
  :disabled t
  :config
  (global-origami-mode))
#+END_SRC

** Apropospriate theme
   
I'm currently running Solarized dark but my move to this in the future.

#+BEGIN_SRC emacs-lisp :tangle yes :exports code
(use-package apropospriate-theme
;;  :ensure t
  :disabled t)
#+END_SRC

** Jabber

This is a placeholder for the Jabber configuration.  I need to determine what values to use for the work server.
   
#+BEGIN_SRC emacs-lisp :tangle yes :exports code
(use-package jabber
;;  :ensure t
  :disabled t)
#+END_SRC 

** Langtool

When writing documentation it is helpful to know if you are using the English language correctly.  Langtool will analyze the buffer and find grammatical errors.

#+BEGIN_SRC emacs-lisp :tangle yes :exports code
  (use-package langtool
;;    :ensure t
    :disabled t
    :config
    (setq langtool-language-tool-jar "~/emacs/Langtool/languagetool-commandline.jar"
          langtool-mother-tongue "en-us"
          langtool-disabled-rules '("WHITESPACE_RULE"
                                    "EN_UNPAIRED_BRACKETS"
                                    "COMMA_PARENTHESIS_WHITESPACE"
                                    "EN_QUOTES")))
#+END_SRC

I am playing with the idea of keeping a languagetool HTTP server running in the background.

#+BEGIN_SRC emacs-lisp :tangle no
(use-package http-post-simple
;;  :ensure t
  :config
  (progn

    (defun check-word)
    (let ((url-request-method        "POST")
          (url-request-extra-headers `(("Content-Type" . "application/x-www-form-urlencoded")))
          (url-request-data          "language=en-us&text=Ifdsjfh."))
      (with-current-buffer (url-retrieve-synchronously "http://localhost:8081")
        (buffer-string)))))
#+END_SRC

** Sr-Speedbar

Speedbar.  It seems like such a nice thing to have and yet I rarely ever use it.  When in Eclipse I use it all the time but the need is not really there when using Emacs.  May be I will enable it again at some point in time.

#+BEGIN_SRC emacs-lisp :tangle yes :exports code
(use-package sr-speedbar
;;  :ensure t
  :commands (sr-speedbar-toggle)
  :disabled t
  :config
  (progn
    (setq sr-speedbar-skip-other-window-p nil)
    (setq speedbar-use-images nil)
    (setq sr-speedbar-right-side t)))
#+END_SRC

** Fold This

A folding package based on the active region.

#+BEGIN_SRC emacs-lisp :tangle yes :exports code
(use-package fold-this
;;  :ensure t
  :disabled t
  :bind (("C-c C-f" . fold-this-all)
         ("C-c C-F" . fold-this)
         ("C-c M-f" . fold-this-unfold-all)))
#+END_SRC

** Mediawiki

For editing the MediaWiki at work.  An old version of Mediawiki is being used which is incompatible so this is only being used for the little code coloring that it provides.  As such the keybinding for C-x C-s that is provided by the mode is overwritten by the default action.             

#+BEGIN_SRC emacs-lisp :tangle yes :exports code
(use-package mediawiki
;;  :ensure t
  :disabled t
  :commands mediawiki-mode
  :config
  (eval-after-load 'mediawiki
    (define-key mediawiki-mode-map (kbd "C-x C-s") 'save-buffer)))
#+END_SRC

** Lineum Relative

I don't typically have need to show line numbers but when I do it is helpful to see the relative line numbers instead of only the absolute.

#+BEGIN_SRC emacs-lisp :tangle yes :exports code
(use-package linum-relative
;;  :ensure t
  :disabled t
  :commands linum-mode
  :config
  (progn
    (setq linum-format 'linum-relative)
    (setq linum-relative-current-symbol "")))
#+END_SRC

** Change Inner

Call the change--inner and then the starting character to modify the inside portion of the group.  Not sure if this will get use.  One of those things that could save a lot of time but there is a need to change a deep habit.

#+BEGIN_SRC emacs-lisp :tangle yes :exports code
(use-package change-inner
;;  :ensure t
  :disabled t
  :bind (("M-i" . change-inner)
         ("M-o" . change-outer)))
#+END_SRC

** Workgroups2

Used to create a workspace when working in eclim.

#+BEGIN_SRC emacs-lisp :tangle yes :exports code
(use-package workgroups2
;;  :ensure t
  :disabled t
  :diminish workgroups-mode
  :config
  (progn
    (setq wg-prefix-key (kbd "C-c w"))
    (setq wg-session-file "~/.emacs.d/.emacs_workgroups")
    (workgroups-mode 1)))
#+END_SRC

** Highlight-symbol

Not sure if this package will stay around either.  It is used for highlighting the sysmbol at point.  Highlights a lot if it is enabled in a buffer that has a lot of the same word.

#+BEGIN_SRC emacs-lisp :tangle yes :exports code
(use-package highlight-symbol
;;  :ensure t
  :disabled highlight-symbol-mode
  :config
  (progn
    (add-hook 'prog-mode-hook 'highlight-symbol-mode)
    (setf highlight-symbol-idle-delay 0)))
#+END_SRC


** With editor

Sets up the with-editor package so things that invoke $EDITOR will use the current emacs if I'm already inside of emacs 

#+BEGIN_SRC emacs-lisp :tangle yes :exports code
(use-package with-editor
  :ensure t
  :disabled t
  :init
  (progn
    (add-hook 'shell-mode-hook  'with-editor-export-editor)
    (add-hook 'eshell-mode-hook 'with-editor-export-editor)))
#+END_SRC

* Disable debugging

Startup is done so stop debugging.

#+BEGIN_SRC emacs-lisp :tangle yes :exports code
(setq debug-on-error nil
      debug-on-quit nil)
#+END_SRC

* Temp

#+BEGIN_SRC emacs-lisp :tangle yes :exports code
;; via http://emacs.stackexchange.com/questions/17327/how-to-have-c-offset-style-correctly-detect-a-java-constructor-and-change-indent
(defun my/point-in-defun-declaration-p ()
  (let ((bod (save-excursion (c-beginning-of-defun)
                             (point))))
    (<= bod
        (point)
        (save-excursion (goto-char bod)
                        (re-search-forward "{")
                        (point)))))

(defun my/is-string-concatenation-p ()
  "Returns true if the previous line is a string concatenation"
  (save-excursion
    (let ((start (point)))
      (forward-line -1)
      (if (re-search-forward " \\\+$" start t) t nil))))

(defun my/inside-java-lambda-p ()
  "Returns true if point is the first statement inside of a lambda"
  (save-excursion
    (c-beginning-of-statement-1)
    (let ((start (point)))
      (forward-line -1)
      (if (search-forward " -> {" start t) t nil))))

(defun my/trailing-paren-p ()
  "Returns true if point is a training paren and semicolon"
  (save-excursion
    (end-of-line)
    (let ((endpoint (point)))
      (beginning-of-line)
      (if (re-search-forward "[ ]*);$" endpoint t) t nil))))

(defun my/prev-line-call-with-no-args-p ()
  "Return true if the previous line is a function call with no arguments"
  (save-excursion
    (let ((start (point)))
      (forward-line -1)
      (if (re-search-forward ".($" start t) t nil))))

(defun my/arglist-cont-nonempty-indentation (arg)
  (if (my/inside-java-lambda-p)
      '+
    (if (my/is-string-concatenation-p)
        16 ;; TODO don't hard-code
      (unless (my/point-in-defun-declaration-p) '++))))

(defun my/statement-block-intro (arg)
  (if (and (c-at-statement-start-p) (my/inside-java-lambda-p)) 0 '+))

(defun my/block-close (arg)
  (if (my/inside-java-lambda-p) '- 0))

(defun my/arglist-close (arg) 
  (if (my/trailing-paren-p) 0 '--))

(defun my/arglist-intro (arg)
  (if (my/prev-line-call-with-no-args-p) '++ 0))

(defconst intellij-java-style
  '((c-basic-offset . 4)
    (c-comment-only-line-offset . (0 . 0))
    ;; the following preserves Javadoc starter lines
    (c-offsets-alist
     .
     ((inline-open . 0)
      (topmost-intro-cont    . +)
      (statement-block-intro . my/statement-block-intro)
      (block-close           . my/block-close)
      (knr-argdecl-intro     . +)
      (substatement-open     . +)
      (substatement-label    . +)
      (case-label            . +)
      (label                 . +)
      (statement-case-open   . +)
      (statement-cont        . +)
      (arglist-intro         . my/arglist-intro)
      (arglist-cont-nonempty . (my/arglist-cont-nonempty-indentation c-lineup-arglist))
      (arglist-close         . my/arglist-close)
      (inexpr-class          . 0)
      (access-label          . 0)
      (inher-intro           . ++)
      (inher-cont            . ++)
      (brace-list-intro      . +)
      (func-decl-cont        . ++))))
  "Elasticsearch's Intellij Java Programming Style")

(c-add-style "intellij" intellij-java-style)
(customize-set-variable 'c-default-style
                        '((java-mode . "intellij")
                          (awk-mode . "awk")
                          (other . "gnu")))
  #+END_SRC

* Investigate
** ejc-sql
   Package for connecting to databases using clojure and JDBC.  
** HEX -> ASCII

Need a way to go from a hex string to a UTF-16 String.

#+BEGIN_SRC emacs-lisp :tangle yes :exports code
(defun ry/hex-to-ascii (beg end)
  ""
  (interactive
   (if (use-region-p)
       (list (region-beginning) (region-end))
     (let ((beg (point-min))
           (end (point-max)))
       (list beg end))))
  (let* ((hex-string (buffer-substring-no-properties beg end))
         (ascii-string (concat
                        (--map
                         (string-to-number (concat it) 16)
                         (-partition 2 (string-to-list hex-string))))))
    (decode-coding-string (string-make-unibyte ascii-string) 'utf-16)
    (delete-region beg end)
    (setq-local buffer-file-coding-system 'utf-16)
    (insert ascii-string)))
#+END_SRC

* Provide
  
#+BEGIN_SRC emacs-lisp :tangle yes :exports code
(provide 'emacs-config)
;;; emacs-config.el ends here
#+END_SRC

